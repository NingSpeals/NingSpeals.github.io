{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-09-15T08:31:44.333Z","updated":"2022-09-14T06:11:06.597Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2022-10-20T04:04:20.038Z","updated":"2022-09-14T06:11:06.597Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"关于我","date":"2022-10-20T08:36:38.704Z","updated":"2022-10-20T08:36:38.696Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"1234567891011121314151617181920name: &#x27;NingSpeals&#x27;age: 1990.05,gender: &#x27;女&#x27;,profession: &#x27;iOS Developer&#x27;,experience: &#x27;6年&#x27;,address: &#x27;上海市&#x27;,education: &#x27;本科&#x27;,github: &#x27;https://github.com/wangshuningyin&#x27;,blog: &#x27;https://wangshuningyin.github.io&#x27;,email: &#x27;ningspeals@163.com&#x27;,skills: [ [&#x27;Html&#x27;, &#x27;Javascript&#x27;, &#x27;swift&#x27;, &#x27;CSS&#x27;, &#x27; Object C&#x27;, &#x27;Java&#x27;, &#x27;Flutter&#x27;], [&#x27;Git&#x27;, &#x27;SVN&#x27;],],devTools: [ [&#x27;Sublime Text&#x27;, &#x27;Visual Studio Code&#x27;, &#x27;Xcode&#x27;], [&#x27;SourceTree&#x27;, &#x27;TortoiseSVN&#x27;],]"},{"title":"友情链接","date":"2022-10-20T03:31:27.597Z","updated":"2022-09-14T06:11:06.598Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-09-15T08:31:44.409Z","updated":"2022-09-14T06:11:06.598Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-09-15T08:31:44.397Z","updated":"2022-09-14T06:11:06.598Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-09-15T08:31:44.372Z","updated":"2022-09-14T06:11:06.598Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Flutter使用qr_code_scanner遇到的问题","slug":"Flutter使用qr_code_scanner遇到的问题","date":"2021-06-15T08:23:05.000Z","updated":"2022-10-20T08:29:56.938Z","comments":true,"path":"2021/06/15/Flutter使用qr_code_scanner遇到的问题/","link":"","permalink":"http://example.com/2021/06/15/Flutter%E4%BD%BF%E7%94%A8qr_code_scanner%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"一、引入qr_code_scanner: ^0.7.0出现的问题1.在flutter项目中的pubspec.yaml引入 qr_code_scanner: ^0.7.0后，编译项目，fluter项目中出现的问题如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192Launching lib/main.dart on 王淑宁的iPhone in debug mode...Automatically signing iOS for device deployment using specified development team in Xcode project: N7XTE6J8P8CocoaPods&#x27; output:↳ Preparing Analyzing dependencies Inspecting targets to integrate Using `ARCHS` setting to build architectures of target `Pods-Runner`: (``) Fetching external sources -&gt; Fetching podspec for `Flutter` from `Flutter` -&gt; Fetching podspec for `qr_code_scanner` from `.symlinks/plugins/qr_code_scanner/ios` Resolving dependencies of `Podfile` CDN: trunk Relative path: CocoaPods-version.yml exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: all_pods_versions_0_2_a.txt exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.11/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.11/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.10/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.9/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.8/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.7/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.6/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.5/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.3/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.2/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/4.0.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/3.1.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/3.0.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/2.1.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/2.0.3/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/2.0.2/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/2.0.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.9.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.9.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.11/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.10/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.9/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.8/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.7/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.6/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.5/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.4/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.3/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.7.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.7.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.6.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.6.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.5.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.4.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.3.2/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.3.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.2.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.1.18/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.8/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.7/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.6/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.5/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.4/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.3/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.2/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update Comparing resolved specification to the sandbox manifest A Flutter A MTBBarcodeScanner A qr_code_scanner Downloading dependencies -&gt; Installing Flutter (1.0.0) -&gt; Installing MTBBarcodeScanner (5.0.11) &gt; Copying MTBBarcodeScanner from `/Users/ningspeals/Library/Caches/CocoaPods/Pods/Release/MTBBarcodeScanner/5.0.11-f453b` to `Pods/MTBBarcodeScanner` -&gt; Installing qr_code_scanner (0.2.0) - Running pre install hooks [!] The following Swift pods cannot yet be integrated as static libraries: The Swift pod `qr_code_scanner` depends upon `MTBBarcodeScanner`, which does not define modules. To opt into those targets generating module maps (which is necessary to import them from Swift when building as static libraries), you may set `use_modular_headers!` globally in your Podfile, or specify `:modular_headers =&gt; true` for particular dependencies. /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer/xcode/target_validator.rb:151:in `verify_swift_pods_have_module_dependencies&#x27; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer/xcode/target_validator.rb:40:in `validate!&#x27; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer.rb:597:in `validate_targets&#x27; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer.rb:163:in `install!&#x27; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/command/install.rb:52:in `run&#x27; /Library/Ruby/Gems/2.6.0/gems/claide-1.0.3/lib/claide/command.rb:334:in `run&#x27; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/command.rb:52:in `run&#x27; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/bin/pod:55:in `&lt;top (required)&gt;&#x27; /usr/local/bin/pod:25:in `load&#x27; /usr/local/bin/pod:25:in `&lt;main&gt;&#x27;Error output from CocoaPods:↳ [!] Automatically assigning platform `iOS` with version `9.0` on target `Runner` because no platform was specified. Please specify a platform for this target in your Podfile. See `https://guides.cocoapods.org/syntax/podfile.html#platform`.Exception: Error running pod installExited (sigterm) 2.用Xcode打开IOS项目，编译项目，出现的问题如图1： 二、解决问题的方法出现上述问题的原因 1.网络原因，下载GitHub项目需要翻墙，也就是需要VPN代理解决；打开终端，输入VPN代理命令（eg：export https_proxy&#x3D;http://127.0.0.1:7890 http_proxy&#x3D;http://127.0.0.1:7890 all_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:7890），cd到相应的iOS目录中，pod update 或 pod install，具体操作步骤如图2： 2.上图中错误有两种原因导致，Xcode中的Podfile文件中没有引入 use_frameworks!或者没有引入use_modular_headers!打开Xcode中的Podfile文件，引入 use_frameworks!或 use_modular_headers!，具体操作如图3所示（在图中圈出地方引入）： #####3.ios 链接库的问题操作完1.2后，在编译iOS项目，出现ld: library not found for -lXXX，这里的处理方式是：在iOS项目中打开Build Settings -&gt; Other Link Flags 打开以后，发现里面存在对应的库名称，前面还有一个前缀修饰： -lxxx，把和flutter相关的全部都删掉，然后commod + R。","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://example.com/tags/Flutter/"}]},{"title":"数组和数组的语法","slug":"数组和数组的语法","date":"2020-08-12T07:36:11.000Z","updated":"2022-10-26T03:10:15.174Z","comments":true,"path":"2020/08/12/数组和数组的语法/","link":"","permalink":"http://example.com/2020/08/12/%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E8%AF%AD%E6%B3%95/","excerpt":"","text":"数组的特点 数组是相同类型的变量的集合，所有元素的类型都是一样的 可以指定数组包含的元素个数，最多为int的最大值个 元素有固定的顺序 每个元素都有一个固定的编号，称之为索引(index)，从0开始递增，类型为int 可以像操作变量一样读写数组中的任何一个以安素 数组的创建和使用 数组元素类型[] 变量名 &#x3D; new 数组元素类型[数组长度] 变量名[索引] 可以使用这个变量，可以读取也可以给它赋值 以数组名与实的来理解数组 数组的”实”是一块地址连续的内存，就像是编号连续的一沓白纸。 数组的名，就是这个块连续内存的第一个内存的地址。 数组的交量和基本交量一样，本身是个地址。但是与基本变量不一样的是这个地址的值数组的“名”，也就是数组的第一个地址。 数组&#x3D;数组变星+数组的实体 数组变量(索引)就是在数组原有地址的基础上，加上索引，获得想要的元素 所以索引是从0开始的，因为数组变量的地址就是数组第一个元素的地址，不需要加 数组的长度 数组变量.length可以获得数组的长度 数组创建之后，长度不可以改变 数组索引过界和初始值 访问数组过界出错的例子，数组出界的错误叫做Index0utofeoundException 如果没有把握数组是否会出界，可以把索引和数组长度做比较，注意索引是从0开始的，不是从1开始的 数组里每个元素的都有初始值，初始值和类型有关。对于数字类型，初始值是 0，对于boolean类型，初始值是false. 让变量指向新的数组 数组变量可以指向新的数组实体。这时候，数组变量的值就是新的数组实体的地址了。这种数组变量的赋值操作，叫做让变量指向新的数组。 如果没有别的数组变量指向原来数组实体，也就是说 ，如果没有数组变量 “记得”原来数组的地址，原来的数组实体就再也不可访问了，也就好像“消失”了。 对于非基本类型的变量，计算机都要通过这种“两级跳”的方式来访问。基本类型变量，一跳就可以。","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"字符集编码和字符串","slug":"AndroidStudio中如何创建指定布局的layout文件","date":"2020-08-08T07:35:29.000Z","updated":"2022-10-26T07:59:21.454Z","comments":true,"path":"2020/08/08/AndroidStudio中如何创建指定布局的layout文件/","link":"","permalink":"http://example.com/2020/08/08/AndroidStudio%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E5%B8%83%E5%B1%80%E7%9A%84layout%E6%96%87%E4%BB%B6/","excerpt":"","text":"首先点击右键，New，找到Edit File Templates 在指定的地方勾上 Enable Live Templates 然后再次点击右键 New，就可以看到这个： 然后我们就可以指定我们的布局了：","categories":[{"name":"使用工具","slug":"使用工具","permalink":"http://example.com/categories/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"字符集编码和字符串","slug":"字符集编码和字符串","date":"2020-08-08T07:35:29.000Z","updated":"2022-10-26T07:56:02.749Z","comments":true,"path":"2020/08/08/字符集编码和字符串/","link":"","permalink":"http://example.com/2020/08/08/%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BC%96%E7%A0%81%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"什么是字符集和编码 什么是字符集( Charset ) 字符集就是字符的集合。-般会包含一种语言的字符。比如GBK ，是包含所有常用汉字字符的字符集。ASCII 是包含英文字符的字符集。 字符就是Java中的char , char是character的简写。 什么是编码( Encoding ) char代表一个字符，char的本质也是数字。将数字映射到字符，就叫编码。 将一个字符集映射到数字 ,就是给这个字符集编码。编码是有标准的，所有的计算机系统按照同一个编码标准执行。 有时候编码和字符集会混用。 编码和字符集介绍 常用的字符集简介 ASCI码. ASCI表: hts:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;ASCI&#x2F;309296#3 Unicode包含世界上所有常用字符，编码也有几种，包括UTF-8 ( 8-bit Unicode Tasormation Format ) ，UTF-16等。 Unicode , GBK等所有常用的字符集,都会兼容ASCI。举个例子，字符A在这些所有常用的字符集里，都是对应数字65。 Java中的字符集 Java中用的是UTF-16编码的Unicode. UTF-16用16个 bit ,即两个byte ,这也是char占用两个byte的原因。当把char转成数字的时候，需要用int。 ASCII码和转义符( escape character ) 如何输出特殊字符 ASCII 码+char，通过ASCII表可以找到需要的字符对应的数字。将这个数字转换为char ,然后输出这个char。ASCI 表: hts:&#x2F;&#x2F;baike .baidu.com&#x2F;item&#x2F;ACI&#x2F;309296#3 转义符。转义符用来给字符赋值，也可以用在字符串里面，作为字符串中的一个字符。 转义符语法和常用的转义符 \\n,换行符 \\&quot;,双引号 \\t,制表符 \\xxxx , unicode编码对应的字符。 字符串的“加法” 将变量穿插在字符串中输出 字符串可以和任何类型进行加法运算，则会将这个值的字符拼接到字夺串上。 字符串也可以使用+&#x3D;操作符来拼接 字符串的加法运算符符合加法运算符本身的优先级 字符串不是Java中的基本数据类型 字符串类型的名字叫做String 虽然String不是Java 中的基础类型，但是也可以使用类似的语法Stringstr= “bc&quot;;来创建。开始的时候将其当成基础类型,更容易理解。 String不是Java中的保留字。 String的加法不会改变原String变量的值,改变其值要用赋值语句","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java中的运算符","slug":"Java中的运算符","date":"2020-08-02T07:35:10.000Z","updated":"2022-10-26T08:02:23.271Z","comments":true,"path":"2020/08/02/Java中的运算符/","link":"","permalink":"http://example.com/2020/08/02/Java%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"什么是运算符 运算符对一个或者多个值进行运算，并得出一个运算结果。 运算符的运算结果类型有的是固定的，有时候会根据被计算的值变化。比如两个int 相加，结果的类型就是int。两个byte 相加，返回值的类型也是int。混淆点:除赋值运算符外，运算符本身不会更改变量的值。 比较运算符和布尔运算符比较运算符 &gt; &gt;= &lt; &lt;= ！= == 布尔运算 ！ &amp; &amp;&amp; | || 运算符优先级 （） ！ *, /, % +, - &gt;, &gt;=, &lt;, &lt;= == != &amp;, &amp;&amp;, |, || = 字面值的八进制和十六进制 以0开头的整数为八进制 05就是十进制的5 011就是十进制的9 以0x开头的整数位十六进制 0xF就是十进制的15 0x11就是十进制的17 按位运算符 按位运算符 按位并(AND) :&amp; 按位或(OR) : | 按位异或(XOR) : ^ 按位取反:~ 位移运算符 位移运算符 &gt;&gt; : 符号位不动，其余位右移，符号位后边正数补0，负数补1。又称带符号右移 &gt;&gt;&gt;: 符号位一起右移，左边补0，又称无符号右移 &lt;&lt;: 左移，右边补0。左移没有带符号位一说，因为符号位在最左侧 位运算符不会改变原来变量的值 按位运算符不会改变原本的变量的值 位移运算符不会改变原本的变量的值 位运算符用处按位运算符 掩码（MASK） 位移算符 高效除以2 数据类型自动转换 自动类型转换 不会出现问题的类型转换，编程语言可以做自动类型转换，比如低精度的数字向高精度的数字转换。 自动类型转换可以发生在算数运算，也可以发生在赋值。 数值精度顺序: double&gt;float&gt;long&gt;int&gt; short&gt;byte char 可以转换为int 虽然同样是两个brte,但是因为char是无符号数，值域超出了short 可以表示的范围，所以不可以自动转为short. 强制数据类型转换 强制类型转换 可能出现问题的类型转换,需要使用强制类型转换，比如高精度数值向低精度数值转换。 强制类型转换也是操作符 语法是用小括号括起来的目标类型放在被转换的值前面 强制转换会造成数据精度丢失 数值溢出 数值计算一旦溢出。结果将失去其原有意义。比如，两个正数会加出负数。 要对能够处理的值有大概的估计。 从数值计算溢出理解程序员和编程语言责任的分界线 编程语言的作用 编程语言负责按照语法执行 编程语言负责和计算机交互 程序员的任务 程序员负责理解问题 程序员负责理解程序。并将问题转换为程序 偏程语言不负责解决问题，程序员才负责解决问题","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java中的基本数据类型","slug":"Java中的基本数据类型","date":"2020-07-28T07:22:51.000Z","updated":"2022-10-26T08:02:09.539Z","comments":true,"path":"2020/07/28/Java中的基本数据类型/","link":"","permalink":"http://example.com/2020/07/28/Java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"认识二进制 十进制 每一位可以是0～9这10个值，到10进位。一百用十进制表示就是100，十就10。 二进制 每一位可以是0和1这两个值，到2进位。一百用二进制表示就1100100，十就是1010. 十六进制 每一位可以是0~F这15个值，到16进位。 一百用十六进制表示就是64, 十就是A. bit和byte 一 个二进制的位叫做个bit， 俗称小b。宽带中的单位，都是小b 八个二进制的位，组成一个byte，俗称大B。硬盘等存储的单位，都是大B Byte是计算机中基本的街量存储的单位，计算机在对外使用时不会用小b作为划分存储的单位。 数字的基本数据类型 整数类型 byte占用1个byte，值域是-128 ~ 127 short占用2个byte，值域是-32768 ~ 32767 int占用4个byte，值域是-2147483648 ~ 2147483647.。Java 中整数缺省是int类型 long占用8个byte，值域是-9223372036854774808 ~ 9223372036854774807 浮点(小数)类型 float有精度，值域复杂（正负34028234668528859811704183484516925440 ） double -精度是float的倍，占用8个byte。Java 中整数缺省是double类型。 布尔和字符数据类型 布尔和字符数据类型 boolean 占用4个byte，值域是true，false。 char 占用2个byte，值域是所有字符（最多65535个）","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java编程基础环境搭建（macOS）","slug":"Java编程基础环境搭建（macOS）","date":"2020-06-12T07:13:22.000Z","updated":"2022-10-26T08:01:51.659Z","comments":true,"path":"2020/06/12/Java编程基础环境搭建（macOS）/","link":"","permalink":"http://example.com/2020/06/12/Java%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88macOS%EF%BC%89/","excerpt":"","text":"安装Java 下载JDK（java Development Kit）搜索JDK并下载 检测JDK安装是否成功1.运行java命令：java -version2.运行javac命令 下载 sublimeText编辑器，编写HelloWorld程序 12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println(&quot;hello world!你好，世界&quot;); &#125;&#125; 编译 cd 进入文件所在的路径 java 文件名.java(例如：HelloWorld.java) javac 文件名（注意：这里不需要加文件名后缀）","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"iOS触摸事件响应原理","slug":"iOS中触摸事件传递和响应原理","date":"2020-01-30T06:55:26.000Z","updated":"2022-10-26T08:01:07.038Z","comments":true,"path":"2020/01/30/iOS中触摸事件传递和响应原理/","link":"","permalink":"http://example.com/2020/01/30/iOS%E4%B8%AD%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E5%8E%9F%E7%90%86/","excerpt":"","text":"系统响应阶段 1.手指触摸屏幕，屏幕感受到触摸后，将事件交给IOKit来处理。 2.iOKit将触摸事件封装成iOHIDEvent对象，并通过mach port传递给SpringBoard进程。 mach port是进程端口，各进程间通过它来通信。Springboard是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统收到的触摸事件。 3.Springboard由于接收到触摸事件，因此触发了系统进程的主线程的runloop的source回掉。发生触摸事件的时候，你有可能正在桌面上翻页，也有可能正在头条上看新闻，如果是前者，则触发Springboard主线程的runloop的source0回调，将桌面系统交给系统进程去消耗。而如果是后者，则将触摸事件通过IPC传递给前台app进程，后面的事便是APP内部对于触摸事件的响应了。 APP响应触摸事件 1.APP进程的mach port接收来自Springboard的触摸事件，主线程runloop被唤醒，触发source1回调。 2.source1回调又触发了一个source0回调，将接收到的IOHIDEvent对象封装成UIEvent对象，此时APP将正式开始对于触摸的响应。 3.source0回调将触摸事件添加到UIApplication的事件队列，当触摸事件出队后UIApplication为触摸事件寻找最佳响应着。 4.寻找到最佳响应着之后，接下来的事情便是事件在响应链中传递和响应。 触摸 事件 响应者触摸触摸对象即UITouch对象。一个手指触摸屏幕，就会生成一个UITouch对象，如果多个手指同时触摸，就会生成多个UITouch对象。多个手指先后触摸，如果系统判断多个手指触摸的是同一个地方，那么不会生成多个UITouch对象，而是更新这个UITouch对象，改变其tap count。如果对歌手指触摸的不是同一个地方，那么就会产生对个UITouch对象。 触摸事件触摸事件即UIEvent。UIEvent即对UITouch的一次封装。由于一次触摸事件并不止有一个触摸对象，可能是多指同时触摸。触摸对象集合可以通过allUITouchs属性来获取。 响应者响应着即UIResponser，UIView，UIViewController，UIApplication，UIAppdelegate等实例都是UIResponser，响应者响应触摸事件是由下面的方法来实现的： 123456789//手指触碰屏幕，触摸开始- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//手指在屏幕上移动- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//手指离开屏幕，触摸结束- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//触摸结束前，某个系统事件中断了触摸，例如电话呼入- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event; 寻找最佳响应者当APP通过mach port得到这个触摸事件时，APP中有那么多UIView或者UIViewController，到底应该谁去响应呢？寻找最佳响应者就是找出这个优先级最高的响应对象。 寻找最佳响应着的具体流程如下： 1.UIApplication首先将事件传递给窗口对象（UIWindow），如果有多个UIWindow对象，则先选择最后加上的UIWindow对象。 2.若UIWindow对象能响应这个触摸事件，则继续向其子视图传递，向子视图传递时也是先传递给最后加上的子视图。 若子视图无法响应该事件，则返回父视图，再传递给倒数第二个加入该父视图的子视图。 视图如何判断自己能否响应触摸事件？以下情况不能响应触摸事件： 1.触摸点不在视图范围内。 2.不允许交互： 视图的userInteractionEnabled = NO。 3.隐藏：hidden = YES，如果视图隐藏了，则不能响应事件。 4.透明度：当视图的透明度小于等于0.01时，不能响应事件。 寻找最佳响应者的原理hitTest:withEvent:每个UIView都有一个hitTest:witnEvent:方法。这个方法是寻找最佳响应者的核心方法，同时又是传递事件的桥梁。它的作用是询问事件在当前视图中的响应者。hitTest:withEvent:返回一个UIView对象，作为当前视图层次中的响应者。其默认实现是： 若当前视图无法响应事件，则返回nil。 若当前视图能响应事件，但无子视图可响应事件，则返回当前视图。 若当前视图能响应事件，同时有子视图能响应，则返回子视图层次中的事件响应者。 开始时UIApplication调用UIWindow的hitTest:wuithEvent:方法将触摸事件传递给UIWindow，如果UIWindow能够响应触摸事件，则调用hitTest：withEvent：将事件传递给其子是视图并询问子视图上的最佳响应者，这样一级一级传递下去，获取最终的最佳响应者。hitTest:withEvent:的代码实现大致如下： 12345678910111213141516171819202122232425- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; //3种状态无法响应事件 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil; //触摸点若不在当前视图上则无法响应事件 if ([self pointInside:point withEvent:event] == NO) return nil; //从后往前遍历子视图数组 int count = (int)self.subviews.count; for (int i = count - 1; i &gt;= 0; i--) &#123; // 获取子视图 UIView *childView = self.subviews[i]; // 坐标系的转换,把触摸点在当前视图上坐标转换为在子视图上的坐标 CGPoint childP = [self convertPoint:point toView:childView]; //询问子视图层级中的最佳响应视图 UIView *fitView = [childView hitTest:childP withEvent:event]; if (fitView) &#123; //如果子视图中有更合适的就返回 return fitView; &#125; &#125; //没有在子视图中找到更合适的响应视图，那么自身就是最合适的 return self;&#125; 注意这里的方法pointInside:withEvent:，这个方法是判断触摸点是否在视图范围内。默认的实现是如果触摸点在视图范围内则返回YES，否则返回NO。下面我们在上图中的每个视图层次中添加三个方法来验证之前的分析： 1234567891011- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; NSLog(@&quot;%s&quot;,__func__); return [super hitTest:point withEvent:event];&#125;- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; NSLog(@&quot;%s&quot;,__func__); return [super pointInside:point withEvent:event];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;%s&quot;,__func__);&#125; 点击视图，打印出来的结果是： 12345678-[AView hitTest:withEvent:]-[AView pointInside:withEvent:]-[CView hitTest:withEvent:]-[CView pointInside:withEvent:]-[EView hitTest:withEvent:]-[EView pointInside:withEvent:]-[EView touchesBegan:withEvent:] 这和我们的分析是一致的。 触摸事件的响应通过hitTest:withEvent:已经找到了最佳响应者，现在要做的事情是让这个最佳响应者触摸事件。这个最佳响应者对于触摸事件拥有决定权，它可以决定是自己响应这个事件，也可以自己响应之后还把它传递给其他响应者，这个响应者构成的就是响应链。响应者对于事件的响应和传递都是在touchesBegan:withEvent这个方法中完成的。该方法默认的实现是将该方法沿着响应链往下传递响应者对于接受到的事件有三种操作： 1.默认的操作。不拦截，事件会沿着默认的响应链自动往下传递。 2.拦截，不在往下分发事件，重写touchesBegan:withEvent:方法，不调用父类的touchesBegan:withEvent:方法。 3.不拦截，继续往下分发事件，重新touchesBegan:withEvent方法，并调用父类touchesBegan:withEvent:方法。我们一般在编写代码时，如果某个视图响应事件，会在该视图类中重写touchesBegan:withEvent:方法，但是并不会调用父类的touchesBegan:withEvent:方法，这样我们就把这个事件拦截下来，不在沿着响应链往下传递。那么我们为什么想要沿着响应链传递事件就要写父类的touchesBegan:withEvent:方法呢？因为父类的touchesBegan:withEvent:方法默认是向下传递的。重写touchesBegan:withEvent:并调用父类的方法就是既对触摸事件实现了响应，又将事件沿着响应链传递了。 响应链中的事件传递规则每一个响应者对象都又一个nextResponder方法，用来获取响应链中当前响应者对象的下一个响应者。硬刺，如果事件的最佳响应者确定了，那么整个响应链也就确定了。对于响应者对象，默认的nextResponse对象如下： UIView若视图是UIViewController的view，则其nextResponder是UIViewController，若其只是单独的视图，则其nextResponser是其父视图。 UIViewController若该视图是window的根视图，则其nextResponser是UIViewController，若其是由其他视图控制器present的，则其nextResponder是presenting view controller。 UIWindownextResponder为UIApplication对象。如果最佳响应者对象是UITextField，则响应链为：UITextField-&gt;UIView-&gt;UIView-&gt;UIViewController-&gt;UIWindow-&gt;UIApplication-&gt;UIApplicationDelegate.在父类的touchesBegan:withEvent:方法中，可能调用了[self.nextResponder touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event]这样来将事件沿着响应链传递。 UIControlUIControl是系统提供的能够以target-action模式处理触摸事件的控件，iOS中UIButton、UISegmentedControl、UISwitch等控件都是UIControl的子类。当UIControl跟踪到触摸事件时，会向其上添加的target发送事件以执行action。UIConotrol是UIView的子类，因此本身也具备UIResponder应有的身份。 UIControl会阻止父视图上的手势识别器的行为，也就是UIControl的执行优先级比父视图上面的UIGestureRecognizer要高，但是比UIControl自身的UIGestureRecognizer优先级要低。","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]},{"title":"IOS UITextFiled 用中文键盘输英文出现空格的解决方案","slug":"IOS-UITextFiled-用中文键盘输英文出现空格的解决方案","date":"2018-07-22T09:14:32.000Z","updated":"2022-10-20T08:29:39.135Z","comments":true,"path":"2018/07/22/IOS-UITextFiled-用中文键盘输英文出现空格的解决方案/","link":"","permalink":"http://example.com/2018/07/22/IOS-UITextFiled-%E7%94%A8%E4%B8%AD%E6%96%87%E9%94%AE%E7%9B%98%E8%BE%93%E8%8B%B1%E6%96%87%E5%87%BA%E7%8E%B0%E7%A9%BA%E6%A0%BC%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"获取textFiled的值的时候，英文，数字键盘是没有问题的，假设输入的是abcd，获取的值是abcd，但是如果使用中文键盘的时候，同样输入abcd，获取到的却是a b c d 字符之间出现了空格。 试了这方法 1NSString *strUrl = [urlString stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;]; 并没什么用然后再利用这个方法 1NSString *strUrl = [urlString stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]]; 也没什么用 最终找到此方法 1NSString *strUrl = [[urlString componentsSeparatedByCharactersInSet:[NSCharacterSet whitespaceCharacterSet]] componentsJoinedByString:@&quot;&quot;];","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]},{"title":"UIScrollView下拉刷新加载数据","slug":"UIScrollView下拉刷新加载数据","date":"2017-11-25T09:07:04.000Z","updated":"2022-10-26T08:02:34.710Z","comments":true,"path":"2017/11/25/UIScrollView下拉刷新加载数据/","link":"","permalink":"http://example.com/2017/11/25/UIScrollView%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE/","excerpt":"","text":"首先为UIScrollView添加加载提示View12345UILabel *refresh = [[UILabel alloc] initWithFrame:CGRectMake(0, -50, 320, 50)];refresh.text = @&quot;下拉刷新&quot;;self.refresh = refresh;refresh.tag = 0;[scrollV addSubview:refresh]; 实现UIScrollViewDelegate1234567891011121314151617181920212223242526272829303132//offset发生改变-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; if (scrollView.contentOffset.y &lt;= -50) &#123; if (self.refresh.tag == 0) &#123; self.refresh.text = @&quot;松开刷新&quot;; &#125; self.refresh.tag = 1; &#125;else&#123; //防止用户在下拉到contentOffset.y &lt;= -50后不松手，然后又往回滑动，需要将值设为默认状态 self.refresh.tag = 0; self.refresh.text = @&quot;下拉刷新&quot;; &#125;&#125;//即将结束拖拽- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint*)targetContentOffset&#123; if (self.refresh.tag == 1) &#123; [UIView animateWithDuration:.3 animations:^&#123; self.refresh.text = @&quot;加载中&quot;; scrollView.contentInset = UIEdgeInsetsMake(50.0f, 0.0f, 0.0f, 0.0f); &#125;]; //数据加载成功后执行；这里为了模拟加载效果，一秒后执行恢复原状代码 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC), dispatch_get_main_queue(), ^&#123; [UIView animateWithDuration:.3 animations:^&#123; self.refresh.tag = 0; self.refresh.text = @&quot;下拉刷新&quot;; scrollView.contentInset = UIEdgeInsetsMake(0, 0, 0, 0); &#125;]; &#125;); &#125;&#125;","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]},{"title":"程序执行流程语句","slug":"程序执行流程语句","date":"2017-11-25T09:07:04.000Z","updated":"2022-10-26T03:09:36.508Z","comments":true,"path":"2017/11/25/程序执行流程语句/","link":"","permalink":"http://example.com/2017/11/25/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"if-else语法 if-else语法，只有一个一个语块被执行 if和else都是java中的关键字 把if-else看作一个表达式，程序整体还是顺序执行的 使用if-else来多买两个包子下面就从买包子问题来理解： 买三个包子， 如果是刚出笼的热包子呢，就多买两个呢？12345678910111213public class BuyBaoZi &#123; public static void main(String[] args)&#123; int baozi = 3; boolean iSHotBaozi = false; System.out.println(&quot;买了&quot;+baozi+&quot;个肉包子&quot;); if (iSHotBaozi)&#123; baozi = baozi + 2; System.out.println(&quot;包子刚出笼，买了&quot;+baozi+&quot;个肉包子&quot;); &#125;else&#123; System.out.println(&quot;买了&quot;+baozi+&quot;个肉包子&quot;); &#125; &#125;&#125; if-else的嵌套求最大的数 if-else就是一个语句，可以是另一个语句的一部分，也可以是if-else的一部分，即嵌套。下从求a，b，c三个数的最大数来理解：123456789101112131415161718192021222324252627282930313233343536public class JudgeSize &#123; public static void main(String[] args) &#123; int a = 99; int b = 88; int c = 99; if (a == b &amp;&amp; b == c) &#123; System.out.println(&quot;a,b,c的值相同&quot;); &#125; else &#123; if (a &gt; b) &#123; if (a &gt; c) &#123; System.out.println(&quot;a是最大的值，为&quot; + a); &#125; else &#123; if (a == c) &#123; System.out.println(&quot;a和c的最大值，为&quot; + a); &#125; else &#123; System.out.println(&quot;c是最大值，为&quot; + c); &#125; &#125; &#125; else &#123; if (b &gt; c) &#123; if (a == b) &#123; System.out.println(&quot;a和b等大，为&quot; + a); &#125; else &#123; System.out.println(&quot;b最大，为&quot; + b); &#125; &#125; else &#123; if (c == b) &#123; System.out.println(&quot;b和c等大，为&quot; + c); &#125; else &#123; System.out.println(&quot;c最大，为&quot; + c); &#125; &#125; &#125; &#125; &#125;&#125; 循环for语句 使用for语句让程序简洁 让程序在满足某条件时，重复执行某个代码块，for是Java中的关键字 初始语句在for循环开始前执行一次，以后不再执行；循环体条件表达式在每次循环体执行前会执行，如果为true ，则执行循环体，否则循环结束；循环体后语句会在每次循环执行后被执行；123for (初始语句;循环体条件表达式;循环体后语句) &#123; for循环&#125; 下面来看下for语句的简单例程：123456789public class Print26Chars &#123; public static void main(String[] args)&#123; char ch = &#x27;A&#x27;; int num = ch; for (int i = 0;i&lt;26;i++)&#123; System.out.println((num+i) + &quot;\\t&quot;+(char)(num+i)); &#125; &#125;&#125; Break语句 break语句可以结束循环下面来看下在求整除程序中使用break提前结束循环：12345678910111213141516171819202122public class FindDiv &#123; public static void main(String[] args) &#123; int div = 100; int divsor = 2000000000; int found = 0; int n = 10; String start = &quot;从&quot; + div + &quot;开始&quot;; while (found &lt; n)&#123; if (div &lt; 0)&#123; System.out.println(&quot;被除数溢出，计算结束&quot;); break; &#125; if (div%divsor == 0)&#123; found++; System.out.println(div + &quot;可以整除&quot; + divsor + &quot;，商是&quot; + (div / divsor)); &#125; div++; &#125; System.out.println(start+&quot;,共找到&quot;+found+&quot;个可以整除&quot;+divsor+&quot;的数。&quot;); System.out.println(div); &#125;&#125; continue语句 跳过不符合条件的循环 continue语句可以结束当次循环的执行，开始下一次循环体的执行 while语句 条件表达式结果是一个boolean值，如果为true，则执行循环体，如果为false，则循环结束。 while循环体是一个代码块，所以while循环也是可以嵌套别的语句，包括while语句，for语句，if-else语句。123while（条件表达式）&#123; while循环体;&#125; do-while语句循环体至少执行一次。1234do &#123; while循环体;&#125;while（条件表达式）; switch语句 switch语句的语法12345678switch(用于比较的int值)&#123; case 目标值1，对应一个 if else(xxx): 匹配后可以执行的语句 case 目标值2，不可以于别的case子句重复: 匹配后可以执行的语句 default(对应最后的else，可选): 匹配后可以执行的语句&#125; switch语句中用于比较的值，必须是int类型 switch语句是适用于有固定多个目标匹配值，然后执行不同的逻辑情况 必须使用break语句显示的结束一个case子句，否则switch第一个match的case语句开始执行直到遇到break语句或者switch语句结束 default子句是可选的，如果所有的case语句都没有匹配上，才会执行default中的代码。 switch语句例程1234567891011121314151617181920212223242526272829303132333435363738public class SwitchNum &#123; public static void main(String[] args) &#123; int n = 99; String str = n + &quot;对应的中文数字是：&quot;; switch (n)&#123; case 1: str+=&quot;壹·&quot;; break; case 2: str+=&quot;贰&quot;; break; case 3: str+=&quot;叁&quot;; break; case 4: str+=&quot;肆&quot;; break; case 5: str+=&quot;伍&quot;; break; case 6: str+=&quot;陆&quot;; break; case 7: str+=&quot;柒&quot;; break; case 8: str+=&quot;扒&quot;; break; case 9: str+=&quot;玖&quot;; default: System.out.println(&quot;错误的值&quot;+n+&quot;。值需要在大于等于1，小于等于9之间。&quot;); &#125; System.out.println(str); &#125;&#125;","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"类（class）语法元素","slug":"类（class）语法元素","date":"2017-11-25T09:07:04.000Z","updated":"2022-10-26T03:09:27.453Z","comments":true,"path":"2017/11/25/类（class）语法元素/","link":"","permalink":"http://example.com/2017/11/25/%E7%B1%BB%EF%BC%88class%EF%BC%89%E8%AF%AD%E6%B3%95%E5%85%83%E7%B4%A0/","excerpt":"","text":"12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println(&quot;hello world!你好，世界&quot;); &#125;&#125; 类——class HelloWorld 是类名，要与文件名一致。 public class ——告诉Java类名要与代码文件一致，是类的修饰符。 public static void是方法修饰符号。 String[] args是方法参数。 大括号内是方法的内容，又称方法体（method body）。 main 方法最为特殊的一点是，他是Java程序的入口。 System.out.println是Java提供的内置功能，可以将内容输出。 小括号里的内容是参数（parameter）。 没有参数的情况下，System.out.println()会输出一行空行。 总结关键知识点 class 后面的名字是类名 类名必须与源文件的文件名相同，文件名后缀必须是小写的java mian方法是Java程序执行的入口","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"iOS触摸事件响应原理","slug":"iOS触摸事件响应原理","date":"2016-10-17T09:03:21.000Z","updated":"2022-10-20T08:30:45.153Z","comments":true,"path":"2016/10/17/iOS触摸事件响应原理/","link":"","permalink":"http://example.com/2016/10/17/iOS%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E5%8E%9F%E7%90%86/","excerpt":"","text":"系统响应阶段 1.手指触摸屏幕，屏幕感受到触摸后，将事件交给IOKit来处理。 2.iOKit将触摸事件封装成iOHIDEvent对象，并通过mach port传递给SpringBoard进程。 mach port是进程端口，各进程间通过它来通信。Springboard是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统收到的触摸事件。 3.Springboard由于接收到触摸事件，因此触发了系统进程的主线程的runloop的source回掉。发生触摸事件的时候，你有可能正在桌面上翻页，也有可能正在头条上看新闻，如果是前者，则触发Springboard主线程的runloop的source0回调，将桌面系统交给系统进程去消耗。而如果是后者，则将触摸事件通过IPC传递给前台app进程，后面的事便是APP内部对于触摸事件的响应了。 APP响应触摸事件 1.APP进程的mach port接收来自Springboard的触摸事件，主线程runloop被唤醒，触发source1回调。 2.source1回调又触发了一个source0回调，将接收到的IOHIDEvent对象封装成UIEvent对象，此时APP将正式开始对于触摸的响应。 3.source0回调将触摸事件添加到UIApplication的事件队列，当触摸事件出队后UIApplication为触摸事件寻找最佳响应者。 4.寻找到最佳响应着之后，接下来的事情便是事件在响应链中传递和响应。 触摸 事件 响应者触摸触摸对象即UITouch对象。一个手指触摸屏幕，就会生成一个UITouch对象，如果多个手指同时触摸，就会生成多个UITouch对象。多个手指先后触摸，如果系统判断多个手指触摸的是同一个地方，那么不会生成多个UITouch对象，而是更新这个UITouch对象，改变其tap count。如果对歌手指触摸的不是同一个地方，那么就会产生对个UITouch对象。 触摸事件触摸事件即UIEvent。UIEvent即对UITouch的一次封装。由于一次触摸事件并不止有一个触摸对象，可能是多指同时触摸。触摸对象集合可以通过allUITouchs属性来获取。 响应者响应者即UIResponser，UIView，UIViewController，UIApplication，UIAppdelegate等实例都是UIResponser，响应者响应触摸事件是由下面的方法来实现的： 123456789//手指触碰屏幕，触摸开始- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//手指在屏幕上移动- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//手指离开屏幕，触摸结束- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//触摸结束前，某个系统事件中断了触摸，例如电话呼入- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event; 寻找最佳响应者当APP通过mach port得到这个触摸事件时，APP中有那么多UIView或者UIViewController，到底应该谁去响应呢？寻找最佳响应者就是找出这个优先级最高的响应对象。 寻找最佳响应着的具体流程如下： 1.UIApplication首先将事件传递给窗口对象（UIWindow），如果有多个UIWindow对象，则先选择最后加上的UIWindow对象。 2.若UIWindow对象能响应这个触摸事件，则继续向其子视图传递，向子视图传递时也是先传递给最后加上的子视图。 若子视图无法响应该事件，则返回父视图，再传递给倒数第二个加入该父视图的子视图。 视图如何判断自己能否响应触摸事件？以下情况不能响应触摸事件： 1.触摸点不在视图范围内。 2.不允许交互： 视图的userInteractionEnabled = NO。 3.隐藏：hidden = YES，如果视图隐藏了，则不能响应事件。 4.透明度：当视图的透明度小于等于0.01时，不能响应事件。 寻找最佳响应者的原理hitTest:withEvent:每个UIView都有一个hitTest:witnEvent:方法。这个方法是寻找最佳响应者的核心方法，同时又是传递事件的桥梁。它的作用是询问事件在当前视图中的响应者。hitTest:withEvent:返回一个UIView对象，作为当前视图层次中的响应者。其默认实现是： 若当前视图无法响应事件，则返回nil。 若当前视图能响应事件，但无子视图可响应事件，则返回当前视图。 若当前视图能响应事件，同时有子视图能响应，则返回子视图层次中的事件响应者。 开始时UIApplication调用UIWindow的hitTest:wuithEvent:方法将触摸事件传递给UIWindow，如果UIWindow能够响应触摸事件，则调用hitTest：withEvent：将事件传递给其子是视图并询问子视图上的最佳响应者，这样一级一级传递下去，获取最终的最佳响应者。hitTest:withEvent:的代码实现大致如下： 12345678910111213141516171819202122232425- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; //3种状态无法响应事件 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil; //触摸点若不在当前视图上则无法响应事件 if ([self pointInside:point withEvent:event] == NO) return nil; //从后往前遍历子视图数组 int count = (int)self.subviews.count; for (int i = count - 1; i &gt;= 0; i--) &#123; // 获取子视图 UIView *childView = self.subviews[i]; // 坐标系的转换,把触摸点在当前视图上坐标转换为在子视图上的坐标 CGPoint childP = [self convertPoint:point toView:childView]; //询问子视图层级中的最佳响应视图 UIView *fitView = [childView hitTest:childP withEvent:event]; if (fitView) &#123; //如果子视图中有更合适的就返回 return fitView; &#125; &#125; //没有在子视图中找到更合适的响应视图，那么自身就是最合适的 return self;&#125; 注意这里的方法pointInside:withEvent:，这个方法是判断触摸点是否在视图范围内。默认的实现是如果触摸点在视图范围内则返回YES，否则返回NO。下面我们在上图中的每个视图层次中添加三个方法来验证之前的分析： 1234567891011- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; NSLog(@&quot;%s&quot;,__func__); return [super hitTest:point withEvent:event];&#125;- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; NSLog(@&quot;%s&quot;,__func__); return [super pointInside:point withEvent:event];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;%s&quot;,__func__);&#125; 点击视图，打印出来的结果是： 12345678-[AView hitTest:withEvent:]-[AView pointInside:withEvent:]-[CView hitTest:withEvent:]-[CView pointInside:withEvent:]-[EView hitTest:withEvent:]-[EView pointInside:withEvent:]-[EView touchesBegan:withEvent:] 这和我们的分析是一致的。 触摸事件的响应通过hitTest:withEvent:已经找到了最佳响应者，现在要做的事情是让这个最佳响应者触摸事件。这个最佳响应者对于触摸事件拥有决定权，它可以决定是自己响应这个事件，也可以自己响应之后还把它传递给其他响应者，这个响应者构成的就是响应链。响应者对于事件的响应和传递都是在touchesBegan:withEvent这个方法中完成的。该方法默认的实现是将该方法沿着响应链往下传递响应者对于接受到的事件有三种操作： 1.默认的操作。不拦截，事件会沿着默认的响应链自动往下传递。 2.拦截，不在往下分发事件，重写touchesBegan:withEvent:方法，不调用父类的touchesBegan:withEvent:方法。 3.不拦截，继续往下分发事件，重新touchesBegan:withEvent方法，并调用父类touchesBegan:withEvent:方法。我们一般在编写代码时，如果某个视图响应事件，会在该视图类中重写touchesBegan:withEvent:方法，但是并不会调用父类的touchesBegan:withEvent:方法，这样我们就把这个事件拦截下来，不在沿着响应链往下传递。那么我们为什么想要沿着响应链传递事件就要写父类的touchesBegan:withEvent:方法呢？因为父类的touchesBegan:withEvent:方法默认是向下传递的。重写touchesBegan:withEvent:并调用父类的方法就是既对触摸事件实现了响应，又将事件沿着响应链传递了。 响应链中的事件传递规则每一个响应者对象都又一个nextResponder方法，用来获取响应链中当前响应者对象的下一个响应者。硬刺，如果事件的最佳响应者确定了，那么整个响应链也就确定了。对于响应者对象，默认的nextResponse对象如下： UIView若视图是UIViewController的view，则其nextResponder是UIViewController，若其只是单独的视图，则其nextResponser是其父视图。 UIViewController若该视图是window的根视图，则其nextResponser是UIViewController，若其是由其他视图控制器present的，则其nextResponder是presenting view controller。 UIWindownextResponder为UIApplication对象。如果最佳响应者对象是UITextField，则响应链为：UITextField-&gt;UIView-&gt;UIView-&gt;UIViewController-&gt;UIWindow-&gt;UIApplication-&gt;UIApplicationDelegate.在父类的touchesBegan:withEvent:方法中，可能调用了[self.nextResponder touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event]这样来将事件沿着响应链传递。 UIControlUIControl是系统提供的能够以target-action模式处理触摸事件的控件，iOS中UIButton、UISegmentedControl、UISwitch等控件都是UIControl的子类。当UIControl跟踪到触摸事件时，会向其上添加的target发送事件以执行action。UIConotrol是UIView的子类，因此本身也具备UIResponder应有的身份。 UIControl会阻止父视图上的手势识别器的行为，也就是UIControl的执行优先级比父视图上面的UIGestureRecognizer要高，但是比UIControl自身的UIGestureRecognizer优先级要低。","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]},{"title":"Hexo博客for Mac的搭建步骤","slug":"Hexo博客-for-Mac搭建步骤","date":"2016-05-29T07:04:41.000Z","updated":"2022-10-26T07:59:55.973Z","comments":true,"path":"2016/05/29/Hexo博客-for-Mac搭建步骤/","link":"","permalink":"http://example.com/2016/05/29/Hexo%E5%8D%9A%E5%AE%A2-for-Mac%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/","excerpt":"","text":"一、环境配置及安装1.Node.js 移步Node.js官网进行安装。 2.GitXcode自带Git环境，或者移步Git官网进行安装，再或者使用Homebrew安装： $ brew install git 当安装完Node.js和Git之后，就可以进行Hexo安装了： $ sudo npm install -g hexo-cli 安装成功之后可以cd到你想要存放博客的目录，默认为~&#x2F;目录，执行建站命令： $ hexo init BlogName $ npm install // 成功之后的目录结构如下 ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 命令执行结束后，就可以正式使用Hexo了，使用debug模式进行查看： $ hexo s --debug 访问http://localhost:4000就可以看到Hexo的默认界面了。 二、托管博客在本地Hexo搭建好之后就要选择服务器进行托管，这里只讲一下通过Github进行托管的方法。 1.创建仓库进入Github新建仓库，名称格式为UserName.github.io，例如ningspeals.github.io。然后将本地Hexo的站点配置文件的配置仓库修改为当前仓库的git地址 ： $ cd ~/blog/ $ open _config.yml // 修改repository deploy: type: git repository: https://github.com/ningspeals/ningspeals.github.com.git branch: master 此处注意:后面要接Space，这种格式才能被Hexo识别 2.配置ssh key仓库配置好之后，要为你的Github添加ssh public key。 SSH 密钥对可以让您方便的登录到 SSH 服务器，而无需输入密码。由于您无需发送您的密码到网络中，SSH 密钥对被认为是更加安全的方式。 SSH 密钥对总是成双出现的，一把公钥，一把私钥。公钥可以自由的放在您所需要连接的 SSH 服务器上，而私钥必须稳妥的保管好。 所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录 shell，不再要求密码。这样子，我们即可保证了整个登录过程的安全，也不会受到中间人攻击。 —— archlinux page 理解完ssh key之后就可以进行生成了： $ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; Enter file in which to save the key (/Users/xuhaoran/.ssh/id_rsa): // 输入绝对地址和名称，直接enter使用默认 Enter passphrase (empty for no passphrase): // 输入ssh key的密码，直接enter是不使用密码 // 生成成功 The key&#39;s randomart image is: +---[RSA 2048]----+ | ..o . ..+ | | oo. . o.o| | + o . o +B| | o+ +. + =.%| | +S.++ + B+| | ..+O= E *| | +.o .o| | . . | | | +----[SHA256]-----+ 成功生成之后使用任意方法打开.public文件，复制里面的密钥，粘贴到Github -&gt; Settings -&gt; SSH and GPG keys -&gt; New SSH key -&gt;Key中，Title可以随意写。 三、基本使用Hexo会自动生成.md文件在~&#x2F;BlogName&#x2F;source&#x2F;_posts目录下，可以使用各种Markdown编辑器进行博客的书写了。 在每篇文章里面可以配置Front-matter，来标记类别、时间、标签等： title: Terminal命令小结 date: 2017-11-22 13:56:34 tags: - Terminal Command Line 书写完成之后生成generate静态文件后进行部署deploy操作，会让你的文章发到Github托管的服务器上： $ hexo g -d 日常书写之外，如果你还想定制多样化的博客样式，可以使用各种Theme，Hexo默认的样式为landscape，我的博客的样式为yilia。其他各种样式可以去Hexo官网主题搜索。 例如找到yilia主题后进入其Github，使用git进行安装： $ git clone https://github.com/iissnan/hexo-theme-yilia themes/yilia 之后修改站点配置文件中的theme属性： theme: yilia 最后清空缓存并重新生成部署： $ hexo clean$ hexo g -d","categories":[{"name":"使用工具","slug":"使用工具","permalink":"http://example.com/categories/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"Hexo搭建个人博客","slug":"Hexo搭建个人博客","date":"2015-11-05T04:47:44.000Z","updated":"2022-10-26T07:59:28.804Z","comments":true,"path":"2015/11/05/Hexo搭建个人博客/","link":"","permalink":"http://example.com/2015/11/05/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"使用工具","slug":"使用工具","permalink":"http://example.com/categories/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]}],"categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"使用工具","slug":"使用工具","permalink":"http://example.com/categories/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://example.com/tags/Flutter/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"},{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]}