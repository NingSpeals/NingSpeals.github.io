{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-09-15T08:31:44.333Z","updated":"2022-09-14T06:11:06.597Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2022-10-20T04:04:20.038Z","updated":"2022-09-14T06:11:06.597Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-09-15T08:31:44.372Z","updated":"2022-09-14T06:11:06.598Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-10-20T04:04:08.487Z","updated":"2022-09-14T06:11:06.597Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2022-10-20T03:31:27.597Z","updated":"2022-09-14T06:11:06.598Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-09-15T08:31:44.409Z","updated":"2022-09-14T06:11:06.598Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-09-15T08:31:44.397Z","updated":"2022-09-14T06:11:06.598Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Flutter使用qr_code_scanner遇到的问题","slug":"Flutter使用qr_code_scanner遇到的问题","date":"2021-06-15T08:23:05.000Z","updated":"2022-10-20T04:23:39.163Z","comments":true,"path":"2021/06/15/Flutter使用qr_code_scanner遇到的问题/","link":"","permalink":"http://example.com/2021/06/15/Flutter%E4%BD%BF%E7%94%A8qr_code_scanner%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"一、引入qr_code_scanner: ^0.7.0出现的问题1.在flutter项目中的pubspec.yaml引入 qr_code_scanner: ^0.7.0后，编译项目，fluter项目中出现的问题如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192Launching lib/main.dart on 王淑宁的iPhone in debug mode...Automatically signing iOS for device deployment using specified development team in Xcode project: N7XTE6J8P8CocoaPods&#x27; output:↳ Preparing Analyzing dependencies Inspecting targets to integrate Using `ARCHS` setting to build architectures of target `Pods-Runner`: (``) Fetching external sources -&gt; Fetching podspec for `Flutter` from `Flutter` -&gt; Fetching podspec for `qr_code_scanner` from `.symlinks/plugins/qr_code_scanner/ios` Resolving dependencies of `Podfile` CDN: trunk Relative path: CocoaPods-version.yml exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: all_pods_versions_0_2_a.txt exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.11/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.11/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.10/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.9/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.8/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.7/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.6/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.5/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.3/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.2/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/4.0.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/3.1.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/3.0.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/2.1.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/2.0.3/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/2.0.2/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/2.0.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.9.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.9.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.11/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.10/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.9/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.8/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.7/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.6/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.5/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.4/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.3/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.7.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.7.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.6.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.6.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.5.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.4.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.3.2/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.3.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.2.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.1.18/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.8/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.7/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.6/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.5/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.4/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.3/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.2/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update Comparing resolved specification to the sandbox manifest A Flutter A MTBBarcodeScanner A qr_code_scanner Downloading dependencies -&gt; Installing Flutter (1.0.0) -&gt; Installing MTBBarcodeScanner (5.0.11) &gt; Copying MTBBarcodeScanner from `/Users/ningspeals/Library/Caches/CocoaPods/Pods/Release/MTBBarcodeScanner/5.0.11-f453b` to `Pods/MTBBarcodeScanner` -&gt; Installing qr_code_scanner (0.2.0) - Running pre install hooks [!] The following Swift pods cannot yet be integrated as static libraries: The Swift pod `qr_code_scanner` depends upon `MTBBarcodeScanner`, which does not define modules. To opt into those targets generating module maps (which is necessary to import them from Swift when building as static libraries), you may set `use_modular_headers!` globally in your Podfile, or specify `:modular_headers =&gt; true` for particular dependencies. /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer/xcode/target_validator.rb:151:in `verify_swift_pods_have_module_dependencies&#x27; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer/xcode/target_validator.rb:40:in `validate!&#x27; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer.rb:597:in `validate_targets&#x27; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer.rb:163:in `install!&#x27; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/command/install.rb:52:in `run&#x27; /Library/Ruby/Gems/2.6.0/gems/claide-1.0.3/lib/claide/command.rb:334:in `run&#x27; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/command.rb:52:in `run&#x27; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/bin/pod:55:in `&lt;top (required)&gt;&#x27; /usr/local/bin/pod:25:in `load&#x27; /usr/local/bin/pod:25:in `&lt;main&gt;&#x27;Error output from CocoaPods:↳ [!] Automatically assigning platform `iOS` with version `9.0` on target `Runner` because no platform was specified. Please specify a platform for this target in your Podfile. See `https://guides.cocoapods.org/syntax/podfile.html#platform`.Exception: Error running pod installExited (sigterm) 2.用Xcode打开IOS项目，编译项目，出现的问题如图1： 二、解决问题的方法出现上述问题的原因 1.网络原因，下载GitHub项目需要翻墙，也就是需要VPN代理解决；打开终端，输入VPN代理命令（eg：export https_proxy&#x3D;http://127.0.0.1:7890 http_proxy&#x3D;http://127.0.0.1:7890 all_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:7890），cd到相应的iOS目录中，pod update 或 pod install，具体操作步骤如图2： 2.上图中错误有两种原因导致，Xcode中的Podfile文件中没有引入 use_frameworks!或者没有引入use_modular_headers!打开Xcode中的Podfile文件，引入 use_frameworks!或 use_modular_headers!，具体操作如图3所示（在图中圈出地方引入）： #####3.ios 链接库的问题操作完1.2后，在编译iOS项目，出现ld: library not found for -lXXX，这里的处理方式是：在iOS项目中打开Build Settings -&gt; Other Link Flags 打开以后，发现里面存在对应的库名称，前面还有一个前缀修饰： -lxxx，把和flutter相关的全部都删掉，然后commod + R。","categories":[{"name":"Flutter 开发","slug":"Flutter-开发","permalink":"http://example.com/categories/Flutter-%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://example.com/tags/Flutter/"}]},{"title":"Hexo搭建个人博客","slug":"Hexo搭建个人博客","date":"2019-09-08T03:01:36.000Z","updated":"2022-10-20T04:11:03.104Z","comments":true,"path":"2019/09/08/Hexo搭建个人博客/","link":"","permalink":"http://example.com/2019/09/08/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"IOS UITextFiled 用中文键盘输英文出现空格的解决方案","slug":"IOS-UITextFiled-用中文键盘输英文出现空格的解决方案","date":"2018-07-22T09:14:32.000Z","updated":"2022-10-20T04:11:14.243Z","comments":true,"path":"2018/07/22/IOS-UITextFiled-用中文键盘输英文出现空格的解决方案/","link":"","permalink":"http://example.com/2018/07/22/IOS-UITextFiled-%E7%94%A8%E4%B8%AD%E6%96%87%E9%94%AE%E7%9B%98%E8%BE%93%E8%8B%B1%E6%96%87%E5%87%BA%E7%8E%B0%E7%A9%BA%E6%A0%BC%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"获取textFiled的值的时候，英文，数字键盘是没有问题的，假设输入的是abcd，获取的值是abcd，但是如果使用中文键盘的时候，同样输入abcd，获取到的却是a b c d 字符之间出现了空格。 试了这方法 1NSString *strUrl = [urlString stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;]; 并没什么用然后再利用这个方法 1NSString *strUrl = [urlString stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]]; 也没什么用 最终找到此方法 1NSString *strUrl = [[urlString componentsSeparatedByCharactersInSet:[NSCharacterSet whitespaceCharacterSet]] componentsJoinedByString:@&quot;&quot;];","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]},{"title":"UIScrollView下拉刷新加载数据","slug":"UIScrollView下拉刷新加载数据","date":"2017-11-25T09:07:04.000Z","updated":"2022-10-20T04:11:44.765Z","comments":true,"path":"2017/11/25/UIScrollView下拉刷新加载数据/","link":"","permalink":"http://example.com/2017/11/25/UIScrollView%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE/","excerpt":"","text":"首先为UIScrollView添加加载提示View12345UILabel *refresh = [[UILabel alloc] initWithFrame:CGRectMake(0, -50, 320, 50)];refresh.text = @&quot;下拉刷新&quot;;self.refresh = refresh;refresh.tag = 0;[scrollV addSubview:refresh]; 实现UIScrollViewDelegate1234567891011121314151617181920212223242526272829303132//offset发生改变-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; if (scrollView.contentOffset.y &lt;= -50) &#123; if (self.refresh.tag == 0) &#123; self.refresh.text = @&quot;松开刷新&quot;; &#125; self.refresh.tag = 1; &#125;else&#123; //防止用户在下拉到contentOffset.y &lt;= -50后不松手，然后又往回滑动，需要将值设为默认状态 self.refresh.tag = 0; self.refresh.text = @&quot;下拉刷新&quot;; &#125;&#125;//即将结束拖拽- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint*)targetContentOffset&#123; if (self.refresh.tag == 1) &#123; [UIView animateWithDuration:.3 animations:^&#123; self.refresh.text = @&quot;加载中&quot;; scrollView.contentInset = UIEdgeInsetsMake(50.0f, 0.0f, 0.0f, 0.0f); &#125;]; //数据加载成功后执行；这里为了模拟加载效果，一秒后执行恢复原状代码 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC), dispatch_get_main_queue(), ^&#123; [UIView animateWithDuration:.3 animations:^&#123; self.refresh.tag = 0; self.refresh.text = @&quot;下拉刷新&quot;; scrollView.contentInset = UIEdgeInsetsMake(0, 0, 0, 0); &#125;]; &#125;); &#125;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]},{"title":"iOS触摸事件响应原理","slug":"iOS触摸事件响应原理","date":"2016-10-17T09:03:21.000Z","updated":"2022-10-20T04:11:26.273Z","comments":true,"path":"2016/10/17/iOS触摸事件响应原理/","link":"","permalink":"http://example.com/2016/10/17/iOS%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E5%8E%9F%E7%90%86/","excerpt":"","text":"系统响应阶段 1.手指触摸屏幕，屏幕感受到触摸后，将事件交给IOKit来处理。 2.iOKit将触摸事件封装成iOHIDEvent对象，并通过mach port传递给SpringBoard进程。 mach port是进程端口，各进程间通过它来通信。Springboard是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统收到的触摸事件。 3.Springboard由于接收到触摸事件，因此触发了系统进程的主线程的runloop的source回掉。发生触摸事件的时候，你有可能正在桌面上翻页，也有可能正在头条上看新闻，如果是前者，则触发Springboard主线程的runloop的source0回调，将桌面系统交给系统进程去消耗。而如果是后者，则将触摸事件通过IPC传递给前台app进程，后面的事便是APP内部对于触摸事件的响应了。 APP响应触摸事件 1.APP进程的mach port接收来自Springboard的触摸事件，主线程runloop被唤醒，触发source1回调。 2.source1回调又触发了一个source0回调，将接收到的IOHIDEvent对象封装成UIEvent对象，此时APP将正式开始对于触摸的响应。 3.source0回调将触摸事件添加到UIApplication的事件队列，当触摸事件出队后UIApplication为触摸事件寻找最佳响应者。 4.寻找到最佳响应着之后，接下来的事情便是事件在响应链中传递和响应。 触摸 事件 响应者触摸触摸对象即UITouch对象。一个手指触摸屏幕，就会生成一个UITouch对象，如果多个手指同时触摸，就会生成多个UITouch对象。多个手指先后触摸，如果系统判断多个手指触摸的是同一个地方，那么不会生成多个UITouch对象，而是更新这个UITouch对象，改变其tap count。如果对歌手指触摸的不是同一个地方，那么就会产生对个UITouch对象。 触摸事件触摸事件即UIEvent。UIEvent即对UITouch的一次封装。由于一次触摸事件并不止有一个触摸对象，可能是多指同时触摸。触摸对象集合可以通过allUITouchs属性来获取。 响应者响应者即UIResponser，UIView，UIViewController，UIApplication，UIAppdelegate等实例都是UIResponser，响应者响应触摸事件是由下面的方法来实现的： 123456789//手指触碰屏幕，触摸开始- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//手指在屏幕上移动- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//手指离开屏幕，触摸结束- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;//触摸结束前，某个系统事件中断了触摸，例如电话呼入- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event; 寻找最佳响应者当APP通过mach port得到这个触摸事件时，APP中有那么多UIView或者UIViewController，到底应该谁去响应呢？寻找最佳响应者就是找出这个优先级最高的响应对象。 寻找最佳响应着的具体流程如下： 1.UIApplication首先将事件传递给窗口对象（UIWindow），如果有多个UIWindow对象，则先选择最后加上的UIWindow对象。 2.若UIWindow对象能响应这个触摸事件，则继续向其子视图传递，向子视图传递时也是先传递给最后加上的子视图。 若子视图无法响应该事件，则返回父视图，再传递给倒数第二个加入该父视图的子视图。 视图如何判断自己能否响应触摸事件？以下情况不能响应触摸事件： 1.触摸点不在视图范围内。 2.不允许交互： 视图的userInteractionEnabled = NO。 3.隐藏：hidden = YES，如果视图隐藏了，则不能响应事件。 4.透明度：当视图的透明度小于等于0.01时，不能响应事件。 寻找最佳响应者的原理hitTest:withEvent:每个UIView都有一个hitTest:witnEvent:方法。这个方法是寻找最佳响应者的核心方法，同时又是传递事件的桥梁。它的作用是询问事件在当前视图中的响应者。hitTest:withEvent:返回一个UIView对象，作为当前视图层次中的响应者。其默认实现是： 若当前视图无法响应事件，则返回nil。 若当前视图能响应事件，但无子视图可响应事件，则返回当前视图。 若当前视图能响应事件，同时有子视图能响应，则返回子视图层次中的事件响应者。 开始时UIApplication调用UIWindow的hitTest:wuithEvent:方法将触摸事件传递给UIWindow，如果UIWindow能够响应触摸事件，则调用hitTest：withEvent：将事件传递给其子是视图并询问子视图上的最佳响应者，这样一级一级传递下去，获取最终的最佳响应者。hitTest:withEvent:的代码实现大致如下： 12345678910111213141516171819202122232425- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; //3种状态无法响应事件 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil; //触摸点若不在当前视图上则无法响应事件 if ([self pointInside:point withEvent:event] == NO) return nil; //从后往前遍历子视图数组 int count = (int)self.subviews.count; for (int i = count - 1; i &gt;= 0; i--) &#123; // 获取子视图 UIView *childView = self.subviews[i]; // 坐标系的转换,把触摸点在当前视图上坐标转换为在子视图上的坐标 CGPoint childP = [self convertPoint:point toView:childView]; //询问子视图层级中的最佳响应视图 UIView *fitView = [childView hitTest:childP withEvent:event]; if (fitView) &#123; //如果子视图中有更合适的就返回 return fitView; &#125; &#125; //没有在子视图中找到更合适的响应视图，那么自身就是最合适的 return self;&#125; 注意这里的方法pointInside:withEvent:，这个方法是判断触摸点是否在视图范围内。默认的实现是如果触摸点在视图范围内则返回YES，否则返回NO。下面我们在上图中的每个视图层次中添加三个方法来验证之前的分析： 1234567891011- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; NSLog(@&quot;%s&quot;,__func__); return [super hitTest:point withEvent:event];&#125;- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; NSLog(@&quot;%s&quot;,__func__); return [super pointInside:point withEvent:event];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;%s&quot;,__func__);&#125; 点击视图，打印出来的结果是： 12345678-[AView hitTest:withEvent:]-[AView pointInside:withEvent:]-[CView hitTest:withEvent:]-[CView pointInside:withEvent:]-[EView hitTest:withEvent:]-[EView pointInside:withEvent:]-[EView touchesBegan:withEvent:] 这和我们的分析是一致的。 触摸事件的响应通过hitTest:withEvent:已经找到了最佳响应者，现在要做的事情是让这个最佳响应者触摸事件。这个最佳响应者对于触摸事件拥有决定权，它可以决定是自己响应这个事件，也可以自己响应之后还把它传递给其他响应者，这个响应者构成的就是响应链。响应者对于事件的响应和传递都是在touchesBegan:withEvent这个方法中完成的。该方法默认的实现是将该方法沿着响应链往下传递响应者对于接受到的事件有三种操作： 1.默认的操作。不拦截，事件会沿着默认的响应链自动往下传递。 2.拦截，不在往下分发事件，重写touchesBegan:withEvent:方法，不调用父类的touchesBegan:withEvent:方法。 3.不拦截，继续往下分发事件，重新touchesBegan:withEvent方法，并调用父类touchesBegan:withEvent:方法。我们一般在编写代码时，如果某个视图响应事件，会在该视图类中重写touchesBegan:withEvent:方法，但是并不会调用父类的touchesBegan:withEvent:方法，这样我们就把这个事件拦截下来，不在沿着响应链往下传递。那么我们为什么想要沿着响应链传递事件就要写父类的touchesBegan:withEvent:方法呢？因为父类的touchesBegan:withEvent:方法默认是向下传递的。重写touchesBegan:withEvent:并调用父类的方法就是既对触摸事件实现了响应，又将事件沿着响应链传递了。 响应链中的事件传递规则每一个响应者对象都又一个nextResponder方法，用来获取响应链中当前响应者对象的下一个响应者。硬刺，如果事件的最佳响应者确定了，那么整个响应链也就确定了。对于响应者对象，默认的nextResponse对象如下： UIView若视图是UIViewController的view，则其nextResponder是UIViewController，若其只是单独的视图，则其nextResponser是其父视图。 UIViewController若该视图是window的根视图，则其nextResponser是UIViewController，若其是由其他视图控制器present的，则其nextResponder是presenting view controller。 UIWindownextResponder为UIApplication对象。如果最佳响应者对象是UITextField，则响应链为：UITextField-&gt;UIView-&gt;UIView-&gt;UIViewController-&gt;UIWindow-&gt;UIApplication-&gt;UIApplicationDelegate.在父类的touchesBegan:withEvent:方法中，可能调用了[self.nextResponder touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event]这样来将事件沿着响应链传递。 UIControlUIControl是系统提供的能够以target-action模式处理触摸事件的控件，iOS中UIButton、UISegmentedControl、UISwitch等控件都是UIControl的子类。当UIControl跟踪到触摸事件时，会向其上添加的target发送事件以执行action。UIConotrol是UIView的子类，因此本身也具备UIResponder应有的身份。 UIControl会阻止父视图上的手势识别器的行为，也就是UIControl的执行优先级比父视图上面的UIGestureRecognizer要高，但是比UIControl自身的UIGestureRecognizer优先级要低。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]}],"categories":[{"name":"Flutter 开发","slug":"Flutter-开发","permalink":"http://example.com/categories/Flutter-%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://example.com/tags/Flutter/"},{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"},{"name":"iOS","slug":"iOS","permalink":"http://example.com/tags/iOS/"}]}