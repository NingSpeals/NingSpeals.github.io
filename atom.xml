<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-20T08:29:56.938Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter使用qr_code_scanner遇到的问题</title>
    <link href="http://example.com/2021/06/15/Flutter%E4%BD%BF%E7%94%A8qr_code_scanner%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/06/15/Flutter%E4%BD%BF%E7%94%A8qr_code_scanner%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-15T08:23:05.000Z</published>
    <updated>2022-10-20T08:29:56.938Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、引入qr-code-scanner-0-7-0出现的问题"><a href="#一、引入qr-code-scanner-0-7-0出现的问题" class="headerlink" title="一、引入qr_code_scanner: ^0.7.0出现的问题"></a>一、引入qr_code_scanner: ^0.7.0出现的问题</h3><p>1.在flutter项目中的<code>pubspec.yaml</code>引入<code> qr_code_scanner: ^0.7.0</code>后，编译项目，fluter项目中出现的问题如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">Launching lib/main.dart on 王淑宁的iPhone in debug mode...</span><br><span class="line">Automatically signing iOS for device deployment using specified development team in Xcode project: N7XTE6J8P8</span><br><span class="line">CocoaPods&#x27; output:</span><br><span class="line">↳</span><br><span class="line">      Preparing</span><br><span class="line">    Analyzing dependencies</span><br><span class="line">    Inspecting targets to integrate</span><br><span class="line">      Using `ARCHS` setting to build architectures of target `Pods-Runner`: (``)</span><br><span class="line">    Fetching external sources</span><br><span class="line">    -&gt; Fetching podspec for `Flutter` from `Flutter`</span><br><span class="line">    -&gt; Fetching podspec for `qr_code_scanner` from `.symlinks/plugins/qr_code_scanner/ios`</span><br><span class="line">    Resolving dependencies of `Podfile`</span><br><span class="line">      CDN: trunk Relative path: CocoaPods-version.yml exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: all_pods_versions_0_2_a.txt exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.11/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.11/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.10/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.9/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.8/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.7/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.6/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.5/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.3/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.2/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/5.0.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/4.0.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/3.1.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/3.0.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/2.1.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/2.0.3/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/2.0.2/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/2.0.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.9.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.9.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.11/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.10/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.9/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.8/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.7/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.6/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.5/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.4/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.3/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.8.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.7.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.7.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.6.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.6.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.5.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.4.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.3.2/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.3.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.2.0/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/1.1.18/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.8/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.7/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.6/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.5/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.4/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.3/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.2/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">      CDN: trunk Relative path: Specs/0/2/a/MTBBarcodeScanner/0.1.1/MTBBarcodeScanner.podspec.json exists! Returning local because checking is only performed in repo update</span><br><span class="line">    Comparing resolved specification to the sandbox manifest</span><br><span class="line">      A Flutter</span><br><span class="line">      A MTBBarcodeScanner</span><br><span class="line">      A qr_code_scanner</span><br><span class="line">    Downloading dependencies</span><br><span class="line">    -&gt; Installing Flutter (1.0.0)</span><br><span class="line">    -&gt; Installing MTBBarcodeScanner (5.0.11)</span><br><span class="line">      &gt; Copying MTBBarcodeScanner from `/Users/ningspeals/Library/Caches/CocoaPods/Pods/Release/MTBBarcodeScanner/5.0.11-f453b` to `Pods/MTBBarcodeScanner`</span><br><span class="line">    -&gt; Installing qr_code_scanner (0.2.0)</span><br><span class="line">      - Running pre install hooks</span><br><span class="line">    [!] The following Swift pods cannot yet be integrated as static libraries:</span><br><span class="line">    The Swift pod `qr_code_scanner` depends upon `MTBBarcodeScanner`, which does not define modules. To opt into those targets generating module maps (which is necessary to import them from Swift when building as static libraries), you may set `use_modular_headers!` globally in your Podfile, or specify `:modular_headers =&gt; true` for particular dependencies.</span><br><span class="line">    /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer/xcode/target_validator.rb:151:in `verify_swift_pods_have_module_dependencies&#x27;</span><br><span class="line">    /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer/xcode/target_validator.rb:40:in `validate!&#x27;</span><br><span class="line">    /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer.rb:597:in `validate_targets&#x27;</span><br><span class="line">    /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer.rb:163:in `install!&#x27;</span><br><span class="line">    /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/command/install.rb:52:in `run&#x27;</span><br><span class="line">    /Library/Ruby/Gems/2.6.0/gems/claide-1.0.3/lib/claide/command.rb:334:in `run&#x27;</span><br><span class="line">    /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/command.rb:52:in `run&#x27;</span><br><span class="line">    /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/bin/pod:55:in `&lt;top (required)&gt;&#x27;</span><br><span class="line">    /usr/local/bin/pod:25:in `load&#x27;</span><br><span class="line">    /usr/local/bin/pod:25:in `&lt;main&gt;&#x27;</span><br><span class="line">Error output from CocoaPods:</span><br><span class="line">↳</span><br><span class="line">    [!] Automatically assigning platform `iOS` with version `9.0` on target `Runner` because no platform was specified. Please specify a platform for this target in your Podfile. See `https://guides.cocoapods.org/syntax/podfile.html#platform`.</span><br><span class="line">Exception: Error running pod install</span><br><span class="line">Exited (sigterm)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.用Xcode打开IOS项目，编译项目，出现的问题如图1：<br><img src="https://upload-images.jianshu.io/upload_images/6152450-1c0b883ed4466e40.png?imageMogr2/auto-orient/strip,imageView2/2/w/1240" alt="图1"></p><h5 id="二、解决问题的方法"><a href="#二、解决问题的方法" class="headerlink" title="二、解决问题的方法"></a>二、解决问题的方法</h5><p>出现上述问题的原因</p><h6 id="1-网络原因，下载GitHub项目需要翻墙，也就是需要VPN代理解决；"><a href="#1-网络原因，下载GitHub项目需要翻墙，也就是需要VPN代理解决；" class="headerlink" title="1.网络原因，下载GitHub项目需要翻墙，也就是需要VPN代理解决；"></a>1.网络原因，下载GitHub项目需要翻墙，也就是需要VPN代理解决；</h6><p>打开终端，输入VPN代理命令（eg：export https_proxy&#x3D;<a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a> http_proxy&#x3D;<a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a> all_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:7890），cd到相应的iOS目录中，pod update 或 pod install，具体操作步骤如图2：<br><img src="https://upload-images.jianshu.io/upload_images/6152450-5e67a27fa2aeb6fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p><h6 id="2-上图中错误有两种原因导致，Xcode中的Podfile文件中没有引入-use-frameworks-或者没有引入use-modular-headers"><a href="#2-上图中错误有两种原因导致，Xcode中的Podfile文件中没有引入-use-frameworks-或者没有引入use-modular-headers" class="headerlink" title="2.上图中错误有两种原因导致，Xcode中的Podfile文件中没有引入 use_frameworks!或者没有引入use_modular_headers!"></a>2.上图中错误有两种原因导致，Xcode中的Podfile文件中没有引入<code> use_frameworks!</code>或者没有引入<code>use_modular_headers!</code></h6><p>打开Xcode中的Podfile文件，引入<code> use_frameworks!</code>或<code> use_modular_headers!</code>，具体操作如图3所示（在图中圈出地方引入）：<br><img src="https://upload-images.jianshu.io/upload_images/6152450-2e15e0795934e164.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3"></p><p>#####3.<a href="https://www.jianshu.com/p/fadcfaeed19b">ios 链接库的问题</a><br>操作完1.2后，在编译iOS项目，出现ld: library not found for -lXXX，这里的处理方式是：在iOS项目中打开Build Settings -&gt; Other Link Flags 打开以后，发现里面存在对应的库名称，前面还有一个前缀修饰： -lxxx，把和flutter相关的全部都删掉，然后commod + R。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、引入qr-code-scanner-0-7-0出现的问题&quot;&gt;&lt;a href=&quot;#一、引入qr-code-scanner-0-7-0出现的问题&quot; class=&quot;headerlink&quot; title=&quot;一、引入qr_code_scanner: ^0.7.0出现的问题</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Flutter" scheme="http://example.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>数组和数组的语法</title>
    <link href="http://example.com/2020/08/12/%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2020/08/12/%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E8%AF%AD%E6%B3%95/</id>
    <published>2020-08-12T07:36:11.000Z</published>
    <updated>2022-10-26T03:10:15.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h2><ul><li>数组是相同类型的变量的集合，所有元素的类型都是一样的</li><li>可以指定数组包含的元素个数，最多为int的最大值个</li><li>元素有固定的顺序</li><li>每个元素都有一个固定的编号，称之为索引(index)，从0开始递增，类型为int</li><li>可以像操作变量一样读写数组中的任何一个以安素</li></ul><h2 id="数组的创建和使用"><a href="#数组的创建和使用" class="headerlink" title="数组的创建和使用"></a>数组的创建和使用</h2><ul><li>数组元素类型[] 变量名 &#x3D; new 数组元素类型[数组长度]</li><li>变量名[索引] 可以使用这个变量，可以读取也可以给它赋值</li><li><h5 id="以数组名与实的来理解数组"><a href="#以数组名与实的来理解数组" class="headerlink" title="以数组名与实的来理解数组"></a>以数组名与实的来理解数组</h5><ul><li>数组的”实”是一块地址连续的内存，就像是编号连续的一沓白纸。</li><li>数组的名，就是这个块连续内存的第一个内存的地址。</li><li>数组的交量和基本交量一样，本身是个地址。但是与基本变量不一样的是这个地址的值数组的“名”，也就是数组的第一个地址。</li></ul></li><li><h5 id="数组-x3D-数组变星-数组的实体"><a href="#数组-x3D-数组变星-数组的实体" class="headerlink" title="数组&#x3D;数组变星+数组的实体"></a>数组&#x3D;数组变星+数组的实体</h5><ul><li>数组变量(索引)就是在数组原有地址的基础上，加上索引，获得想要的元素</li><li>所以索引是从0开始的，因为数组变量的地址就是数组第一个元素的地址，不需要加</li></ul></li><li><h5 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h5><ul><li>数组变量.length可以获得数组的长度</li><li>数组创建之后，长度不可以改变</li></ul></li><li><h5 id="数组索引过界和初始值"><a href="#数组索引过界和初始值" class="headerlink" title="数组索引过界和初始值"></a>数组索引过界和初始值</h5><ul><li>访问数组过界出错的例子，数组出界的错误叫做<code>Index0utofeoundException</code></li><li>如果没有把握数组是否会出界，可以把索引和数组长度做比较，注意索引是从0开始的，不是从1开始的</li><li>数组里每个元素的都有初始值，初始值和类型有关。对于数字类型，初始值是 0，对于boolean类型，初始值是false.</li></ul></li><li><h5 id="让变量指向新的数组"><a href="#让变量指向新的数组" class="headerlink" title="让变量指向新的数组"></a>让变量指向新的数组</h5><ul><li>数组变量可以指向新的数组实体。这时候，数组变量的值就是新的数组实体的地址了。这种数组变量的赋值操作，叫做让变量指向新的数组。</li><li>如果没有别的数组变量指向原来数组实体，也就是说 ，如果没有数组变量 “记得”原来数组的地址，原来的数组实体就再也不可访问了，也就好像“消失”了。</li><li>对于非基本类型的变量，计算机都要通过这种“两级跳”的方式来访问。基本类型变量，一跳就可以。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组的特点&quot;&gt;&lt;a href=&quot;#数组的特点&quot; class=&quot;headerlink&quot; title=&quot;数组的特点&quot;&gt;&lt;/a&gt;数组的特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数组是相同类型的变量的集合，所有元素的类型都是一样的&lt;/li&gt;
&lt;li&gt;可以指定数组包含的元素个数，最多</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>字符集编码和字符串</title>
    <link href="http://example.com/2020/08/08/AndroidStudio%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E5%B8%83%E5%B1%80%E7%9A%84layout%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2020/08/08/AndroidStudio%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%8C%87%E5%AE%9A%E5%B8%83%E5%B1%80%E7%9A%84layout%E6%96%87%E4%BB%B6/</id>
    <published>2020-08-08T07:35:29.000Z</published>
    <updated>2022-10-26T07:59:21.454Z</updated>
    
    <content type="html"><![CDATA[<p>首先点击右键，New，找到Edit File Templates</p><p><img src="https://img2020.cnblogs.com/blog/1446249/202005/1446249-20200501060035979-1442992578.png"></p><p>在指定的地方勾上 Enable Live Templates</p><p><img src="https://img2020.cnblogs.com/blog/1446249/202005/1446249-20200501060135024-345671532.png"></p><p>然后再次点击右键 New，就可以看到这个：</p><p><img src="https://img2020.cnblogs.com/blog/1446249/202005/1446249-20200501060237472-995697937.png"></p><p>然后我们就可以指定我们的布局了：</p><p><img src="https://img2020.cnblogs.com/blog/1446249/202005/1446249-20200501060552128-247940348.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先点击右键，New，找到Edit File Templates&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1446249/202005/1446249-20200501060035979-1442992578.pn</summary>
      
    
    
    
    <category term="使用工具" scheme="http://example.com/categories/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="其他" scheme="http://example.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>字符集编码和字符串</title>
    <link href="http://example.com/2020/08/08/%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BC%96%E7%A0%81%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2020/08/08/%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BC%96%E7%A0%81%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-08-08T07:35:29.000Z</published>
    <updated>2022-10-26T07:56:02.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是字符集和编码"><a href="#什么是字符集和编码" class="headerlink" title="什么是字符集和编码"></a>什么是字符集和编码</h2><ul><li><h4 id="什么是字符集-Charset"><a href="#什么是字符集-Charset" class="headerlink" title="什么是字符集( Charset )"></a>什么是字符集( Charset )</h4><ul><li>字符集就是字符的集合。-般会包含一种语言的字符。比如GBK ，是包含所有常用汉字字符的字符集。ASCII 是包含英文字符的字符集。</li><li>字符就是Java中的char , char是character的简写。</li></ul></li><li><h4 id="什么是编码-Encoding"><a href="#什么是编码-Encoding" class="headerlink" title="什么是编码( Encoding )"></a>什么是编码( Encoding )</h4><ul><li>char代表一个字符，char的本质也是数字。将数字映射到字符，就叫编码。</li><li>将一个字符集映射到数字 ,就是给这个字符集编码。编码是有标准的，所有的计算机系统按照同一个编码标准执行。</li><li>有时候编码和字符集会混用。</li></ul></li></ul><h2 id="编码和字符集介绍"><a href="#编码和字符集介绍" class="headerlink" title="编码和字符集介绍"></a>编码和字符集介绍</h2><ul><li><h4 id="常用的字符集简介"><a href="#常用的字符集简介" class="headerlink" title="常用的字符集简介"></a>常用的字符集简介</h4><ul><li>ASCI码. ASCI表: hts:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;ASCI&#x2F;309296#3</li><li>Unicode包含世界上所有常用字符，编码也有几种，包括UTF-8 ( 8-bit Unicode Tasormation Format ) ，UTF-16等。</li><li>Unicode , GBK等所有常用的字符集,都会兼容ASCI。举个例子，字符A在这些所有常用的字符集里，都是对应数字65。</li></ul></li><li><h4 id="Java中的字符集"><a href="#Java中的字符集" class="headerlink" title="Java中的字符集"></a>Java中的字符集</h4><ul><li>Java中用的是UTF-16编码的Unicode.</li><li>UTF-16用16个 bit ,即两个byte ,这也是char占用两个byte的原因。当把char转成数字的时候，需要用int。</li></ul></li></ul><h2 id="ASCII码和转义符-escape-character"><a href="#ASCII码和转义符-escape-character" class="headerlink" title="ASCII码和转义符( escape character )"></a>ASCII码和转义符( escape character )</h2><ul><li><h4 id="如何输出特殊字符"><a href="#如何输出特殊字符" class="headerlink" title="如何输出特殊字符"></a>如何输出特殊字符</h4><ul><li>ASCII 码+char，通过ASCII表可以找到需要的字符对应的数字。将这个数字转换为char ,然后输出这个char。ASCI 表: hts:&#x2F;&#x2F;baike .baidu.com&#x2F;item&#x2F;ACI&#x2F;309296#3</li><li>转义符。转义符用来给字符赋值，也可以用在字符串里面，作为字符串中的一个字符。</li></ul></li><li><h4 id="转义符语法和常用的转义符"><a href="#转义符语法和常用的转义符" class="headerlink" title="转义符语法和常用的转义符"></a>转义符语法和常用的转义符</h4><ul><li><code>\n</code>,换行符</li><li><code>\&quot;</code>,双引号</li><li><code>\t</code>,制表符</li><li><code>\xxxx</code> , <code>unicode</code>编码对应的字符。</li></ul></li></ul><h2 id="字符串的“加法”"><a href="#字符串的“加法”" class="headerlink" title="字符串的“加法”"></a>字符串的“加法”</h2><ul><li><h4 id="将变量穿插在字符串中输出"><a href="#将变量穿插在字符串中输出" class="headerlink" title="将变量穿插在字符串中输出"></a>将变量穿插在字符串中输出</h4><ul><li>字符串可以和任何类型进行加法运算，则会将这个值的字符拼接到字夺串上。</li><li>字符串也可以使用+&#x3D;操作符来拼接</li><li>字符串的加法运算符符合加法运算符本身的优先级</li></ul></li><li><h4 id="字符串不是Java中的基本数据类型"><a href="#字符串不是Java中的基本数据类型" class="headerlink" title="字符串不是Java中的基本数据类型"></a>字符串不是Java中的基本数据类型</h4><ul><li>字符串类型的名字叫做String</li><li>虽然String不是Java 中的基础类型，但是也可以使用类似的语法<code>Stringstr= “bc&quot;;</code>来创建。开始的时候将其当成基础类型,更容易理解。</li><li>String不是Java中的保留字。</li><li>String的加法不会改变原String变量的值,改变其值要用赋值语句</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是字符集和编码&quot;&gt;&lt;a href=&quot;#什么是字符集和编码&quot; class=&quot;headerlink&quot; title=&quot;什么是字符集和编码&quot;&gt;&lt;/a&gt;什么是字符集和编码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;什么是字符集-Charset&quot;&gt;&lt;a href=&quot;#什么</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的运算符</title>
    <link href="http://example.com/2020/08/02/Java%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://example.com/2020/08/02/Java%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-08-02T07:35:10.000Z</published>
    <updated>2022-10-26T08:02:23.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是运算符"><a href="#什么是运算符" class="headerlink" title="什么是运算符"></a>什么是运算符</h2><ul><li>运算符对一个或者多个值进行运算，并得出一个运算结果。</li><li>运算符的运算结果类型有的是固定的，有时候会根据被计算的值变化。比如两个int 相加，结果的类型就是int。两个byte 相加，返回值的类型也是int。<br><code>混淆点:除赋值运算符外，运算符本身不会更改变量的值。</code></li></ul><h2 id="比较运算符和布尔运算符"><a href="#比较运算符和布尔运算符" class="headerlink" title="比较运算符和布尔运算符"></a>比较运算符和布尔运算符</h2><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><ul><li><code>&gt;</code></li><li><code>&gt;=</code></li><li><code>&lt;</code></li><li><code>&lt;=</code></li><li><code>！=</code></li><li><code>==</code></li></ul><h4 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h4><ul><li><code>！</code></li><li><code>&amp;</code></li><li><code>&amp;&amp;</code></li><li><code> |</code></li><li><code>||</code></li></ul><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><ul><li><code>（）</code></li><li><code>！</code></li><li><code>*, /, %</code></li><li><code>+, -</code></li><li><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>,<code> &lt;=</code></li><li><code>==</code></li><li><code>!=</code></li><li><code>&amp;, &amp;&amp;, |, ||</code></li><li><code>=</code></li></ul><h2 id="字面值的八进制和十六进制"><a href="#字面值的八进制和十六进制" class="headerlink" title="字面值的八进制和十六进制"></a>字面值的八进制和十六进制</h2><ul><li><h4 id="以0开头的整数为八进制"><a href="#以0开头的整数为八进制" class="headerlink" title="以0开头的整数为八进制"></a>以0开头的整数为八进制</h4><ul><li>05就是十进制的5</li><li>011就是十进制的9</li></ul></li><li><h4 id="以0x开头的整数位十六进制"><a href="#以0x开头的整数位十六进制" class="headerlink" title="以0x开头的整数位十六进制"></a>以0x开头的整数位十六进制</h4><ul><li>0xF就是十进制的15</li><li>0x11就是十进制的17</li></ul></li></ul><h2 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a>按位运算符</h2><ul><li><h4 id="按位运算符-1"><a href="#按位运算符-1" class="headerlink" title="按位运算符"></a>按位运算符</h4><ul><li>按位并(AND) :&amp;</li><li>按位或(OR) : |</li><li>按位异或(XOR) : ^</li><li>按位取反:~</li></ul></li></ul><h2 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h2><ul><li><h4 id="位移运算符-1"><a href="#位移运算符-1" class="headerlink" title="位移运算符"></a>位移运算符</h4><ul><li><code>&gt;&gt;</code> : 符号位不动，其余位右移，符号位后边正数补0，负数补1。又称带符号右移</li><li><code>&gt;&gt;&gt;</code>: 符号位一起右移，左边补0，又称无符号右移</li><li><code>&lt;&lt;</code>: 左移，右边补0。左移没有带符号位一说，因为符号位在最左侧</li></ul></li></ul><h2 id="位运算符不会改变原来变量的值"><a href="#位运算符不会改变原来变量的值" class="headerlink" title="位运算符不会改变原来变量的值"></a>位运算符不会改变原来变量的值</h2><ul><li><h4 id="按位运算符不会改变原本的变量的值"><a href="#按位运算符不会改变原本的变量的值" class="headerlink" title="按位运算符不会改变原本的变量的值"></a>按位运算符不会改变原本的变量的值</h4></li><li><h4 id="位移运算符不会改变原本的变量的值"><a href="#位移运算符不会改变原本的变量的值" class="headerlink" title="位移运算符不会改变原本的变量的值"></a>位移运算符不会改变原本的变量的值</h4></li></ul><h2 id="位运算符用处"><a href="#位运算符用处" class="headerlink" title="位运算符用处"></a>位运算符用处</h2><h4 id="按位运算符-2"><a href="#按位运算符-2" class="headerlink" title="按位运算符"></a>按位运算符</h4><ul><li>掩码（MASK）</li></ul><h4 id="位移算符"><a href="#位移算符" class="headerlink" title="位移算符"></a>位移算符</h4><ul><li>高效除以2</li></ul><h2 id="数据类型自动转换"><a href="#数据类型自动转换" class="headerlink" title="数据类型自动转换"></a>数据类型自动转换</h2><ul><li><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><ul><li>不会出现问题的类型转换，编程语言可以做自动类型转换，比如低精度的数字向高精度的数字转换。</li><li>自动类型转换可以发生在算数运算，也可以发生在赋值。</li></ul></li><li><h4 id="数值精度顺序-double-gt-float-gt-long-gt-int-gt-short-gt-byte"><a href="#数值精度顺序-double-gt-float-gt-long-gt-int-gt-short-gt-byte" class="headerlink" title="数值精度顺序: double&gt;float&gt;long&gt;int&gt; short&gt;byte"></a>数值精度顺序: double&gt;float&gt;long&gt;int&gt; short&gt;byte</h4></li><li><h4 id="char-可以转换为int"><a href="#char-可以转换为int" class="headerlink" title="char 可以转换为int"></a>char 可以转换为int</h4><ul><li>虽然同样是两个brte,但是因为char是无符号数，值域超出了short 可以表示的范围，所以不可以自动转为short.</li></ul></li></ul><h2 id="强制数据类型转换"><a href="#强制数据类型转换" class="headerlink" title="强制数据类型转换"></a>强制数据类型转换</h2><ul><li><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul><li>可能出现问题的类型转换,需要使用强制类型转换，比如高精度数值向低精度数值转换。</li><li>强制类型转换也是操作符</li><li>语法是用小括号括起来的目标类型放在被转换的值前面</li><li>强制转换会造成数据精度丢失</li></ul></li><li><h4 id="数值溢出"><a href="#数值溢出" class="headerlink" title="数值溢出"></a>数值溢出</h4><ul><li>数值计算一旦溢出。结果将失去其原有意义。比如，两个正数会加出负数。</li><li>要对能够处理的值有大概的估计。</li></ul></li></ul><h2 id="从数值计算溢出理解程序员和编程语言责任的分界线"><a href="#从数值计算溢出理解程序员和编程语言责任的分界线" class="headerlink" title="从数值计算溢出理解程序员和编程语言责任的分界线"></a>从数值计算溢出理解程序员和编程语言责任的分界线</h2><ul><li><h4 id="编程语言的作用"><a href="#编程语言的作用" class="headerlink" title="编程语言的作用"></a>编程语言的作用</h4><ul><li>编程语言负责按照语法执行</li><li>编程语言负责和计算机交互</li></ul></li><li><h4 id="程序员的任务"><a href="#程序员的任务" class="headerlink" title="程序员的任务"></a>程序员的任务</h4><ul><li>程序员负责理解问题</li><li>程序员负责理解程序。并将问题转换为程序</li><li>偏程语言不负责解决问题，程序员才负责解决问题</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是运算符&quot;&gt;&lt;a href=&quot;#什么是运算符&quot; class=&quot;headerlink&quot; title=&quot;什么是运算符&quot;&gt;&lt;/a&gt;什么是运算符&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;运算符对一个或者多个值进行运算，并得出一个运算结果。&lt;/li&gt;
&lt;li&gt;运算符的运算结果类型有的</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的基本数据类型</title>
    <link href="http://example.com/2020/07/28/Java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2020/07/28/Java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-07-28T07:22:51.000Z</published>
    <updated>2022-10-26T08:02:09.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识二进制"><a href="#认识二进制" class="headerlink" title="认识二进制"></a>认识二进制</h2><ul><li><h4 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h4><ul><li>每一位可以是0～9这10个值，到10进位。一百用十进制表示就是100，十就10。</li></ul></li><li><h4 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h4><ul><li>每一位可以是0和1这两个值，到2进位。一百用二进制表示就1100100，十就是1010.</li></ul></li><li><h4 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h4><ul><li>每一位可以是0~F这15个值，到16进位。 一百用十六进制表示就是64, 十就是A.</li></ul></li><li><h4 id="bit和byte"><a href="#bit和byte" class="headerlink" title="bit和byte"></a>bit和byte</h4><ul><li>一 个二进制的位叫做个bit， 俗称小b。宽带中的单位，都是小b</li><li>八个二进制的位，组成一个byte，俗称大B。硬盘等存储的单位，都是大B</li><li>Byte是计算机中基本的街量存储的单位，计算机在对外使用时不会用小b作为划分存储的单位。</li></ul></li></ul><h2 id="数字的基本数据类型"><a href="#数字的基本数据类型" class="headerlink" title="数字的基本数据类型"></a>数字的基本数据类型</h2><ul><li><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><ul><li>byte占用1个byte，值域是-128 ~ 127</li><li>short占用2个byte，值域是-32768 ~ 32767</li><li>int占用4个byte，值域是-2147483648 ~ 2147483647.。Java 中整数缺省是int类型</li><li>long占用8个byte，值域是-9223372036854774808 ~ 9223372036854774807</li></ul></li><li><h4 id="浮点-小数-类型"><a href="#浮点-小数-类型" class="headerlink" title="浮点(小数)类型"></a>浮点(小数)类型</h4><ul><li>float有精度，值域复杂（正负34028234668528859811704183484516925440 ）</li><li>double -精度是float的倍，占用8个byte。Java 中整数缺省是double类型。</li></ul></li></ul><h2 id="布尔和字符数据类型"><a href="#布尔和字符数据类型" class="headerlink" title="布尔和字符数据类型"></a>布尔和字符数据类型</h2><ul><li><h4 id="布尔和字符数据类型-1"><a href="#布尔和字符数据类型-1" class="headerlink" title="布尔和字符数据类型"></a>布尔和字符数据类型</h4><ul><li>boolean 占用4个byte，值域是true，false。</li><li>char 占用2个byte，值域是所有字符（最多65535个）</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;认识二进制&quot;&gt;&lt;a href=&quot;#认识二进制&quot; class=&quot;headerlink&quot; title=&quot;认识二进制&quot;&gt;&lt;/a&gt;认识二进制&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;十进制&quot;&gt;&lt;a href=&quot;#十进制&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程基础环境搭建（macOS）</title>
    <link href="http://example.com/2020/06/12/Java%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88macOS%EF%BC%89/"/>
    <id>http://example.com/2020/06/12/Java%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88macOS%EF%BC%89/</id>
    <published>2020-06-12T07:13:22.000Z</published>
    <updated>2022-10-26T08:01:51.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h2><ul><li><p>下载JDK（java Development Kit）<br><a href="https://www.oracle.com/java/technologies/javase-downloads.html">搜索JDK并下载</a></p></li><li><p>检测JDK安装是否成功<br>1.运行java命令：java -version<br><img src="https://upload-images.jianshu.io/upload_images/6152450-48dec0d8dade5298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440" alt="图1"><br>2.运行javac命令<br><img src="https://upload-images.jianshu.io/upload_images/6152450-1024d102f8757396.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440" alt="图2"></p></li><li><p>下载 sublimeText编辑器，编写HelloWorld程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    System.out.println(&quot;hello world!你好，世界&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul><li>cd 进入文件所在的路径</li><li>java 文件名.java(例如：HelloWorld.java)</li><li>javac 文件名（<code>注意：这里不需要加文件名后缀</code>）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装Java&quot;&gt;&lt;a href=&quot;#安装Java&quot; class=&quot;headerlink&quot; title=&quot;安装Java&quot;&gt;&lt;/a&gt;安装Java&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;下载JDK（java Development Kit）&lt;br&gt;&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>iOS触摸事件响应原理</title>
    <link href="http://example.com/2020/01/30/iOS%E4%B8%AD%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2020/01/30/iOS%E4%B8%AD%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E5%8E%9F%E7%90%86/</id>
    <published>2020-01-30T06:55:26.000Z</published>
    <updated>2022-10-26T08:01:07.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统响应阶段"><a href="#系统响应阶段" class="headerlink" title="系统响应阶段"></a>系统响应阶段</h1><ul><li>1.手指触摸屏幕，屏幕感受到触摸后，将事件交给<code>IOKit</code>来处理。</li><li>2.<code>iOKit</code>将触摸事件封装成<code>iOHIDEvent</code>对象，并通过<code>mach port</code>传递给<code>SpringBoard</code>进程。</li></ul><blockquote><p><code>mach port</code>是进程端口，各进程间通过它来通信。<code>Springboard</code>是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统收到的触摸事件。</p></blockquote><ul><li>3.<code>Springboard</code>由于接收到触摸事件，因此触发了系统进程的主线程的<code>runloop</code>的<code>source</code>回掉。发生触摸事件的时候，你有可能正在桌面上翻页，也有可能正在头条上看新闻，如果是前者，则触发<code>Springboard</code>主线程的<code>runloop</code>的<code>source0</code>回调，将桌面系统交给系统进程去消耗。而如果是后者，则将触摸事件通过<code>IPC</code>传递给前台<code>app</code>进程，后面的事便是<code>APP</code>内部对于触摸事件的响应了。</li></ul><h1 id="APP响应触摸事件"><a href="#APP响应触摸事件" class="headerlink" title="APP响应触摸事件"></a>APP响应触摸事件</h1><ul><li><p>1.<code>APP</code>进程的<code>mach port</code>接收来自<code>Springboard</code>的触摸事件，主线程<code>runloop</code>被唤醒，触发<code>source1</code>回调。</p></li><li><p>2.<code>source1</code>回调又触发了一个<code>source0</code>回调，将接收到的<code>IOHIDEvent</code>对象封装成<code>UIEven</code>t对象，此时<code>APP</code>将正式开始对于触摸的响应。</p></li><li><p>3.<code>source0</code>回调将触摸事件添加到<code>UIApplication</code>的事件队列，当触摸事件出队后<code>UIApplication</code>为触摸事件寻找最佳响应着。</p></li><li><p>4.寻找到最佳响应着之后，接下来的事情便是事件在响应链中传递和响应。</p></li></ul><h1 id="触摸-事件-响应者"><a href="#触摸-事件-响应者" class="headerlink" title="触摸 事件 响应者"></a>触摸 事件 响应者</h1><h2 id="触摸"><a href="#触摸" class="headerlink" title="触摸"></a>触摸</h2><p>触摸对象即<code>UITouch</code>对象。一个手指触摸屏幕，就会生成一个<code>UITouch</code>对象，如果多个手指同时触摸，就会生成多个<code>UITouch</code>对象。多个手指先后触摸，如果系统判断多个手指触摸的是同一个地方，那么不会生成多个<code>UITouch</code>对象，而是更新这个<code>UITouch</code>对象，改变其<code>tap count</code>。如果对歌手指触摸的不是同一个地方，那么就会产生对个<code>UITouch</code>对象。</p><h2 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h2><p>触摸事件即<code>UIEvent</code>。<code>UIEvent</code>即对<code>UITouch</code>的一次封装。由于一次触摸事件并不止有一个触摸对象，可能是多指同时触摸。触摸对象集合可以通过<code>allUITouchs</code>属性来获取。</p><h2 id="响应者"><a href="#响应者" class="headerlink" title="响应者"></a>响应者</h2><p>响应着即<code>UIResponser</code>，<code>UIView</code>，<code>UIViewController</code>，<code>UIApplication</code>，<code>UIAppdelegate</code>等实例都是<code>UIResponser</code>，响应者响应触摸事件是由下面的方法来实现的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//手指触碰屏幕，触摸开始</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">//手指在屏幕上移动</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">//手指离开屏幕，触摸结束</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">//触摸结束前，某个系统事件中断了触摸，例如电话呼入</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="寻找最佳响应者"><a href="#寻找最佳响应者" class="headerlink" title="寻找最佳响应者"></a>寻找最佳响应者</h2><p>当<code>APP</code>通过<code>mach port</code>得到这个触摸事件时，<code>APP</code>中有那么多<code>UIView</code>或者<code>UIViewController</code>，到底应该谁去响应呢？寻找最佳响应者就是找出这个优先级最高的响应对象。</p><ul><li>寻找最佳响应着的具体流程如下：</li><li>1.<code>UIApplication</code>首先将事件传递给窗口对象（<code>UIWindow</code>），如果有多个<code>UIWindow</code>对象，则先选择最后加上的<code>UIWindow</code>对象。</li><li>2.若<code>UIWindow</code>对象能响应这个触摸事件，则继续向其子视图传递，向子视图传递时也是先传递给最后加上的子视图。</li><li><ol start="3"><li>若子视图无法响应该事件，则返回父视图，再传递给倒数第二个加入该父视图的子视图。</li></ol></li></ul><h2 id="视图如何判断自己能否响应触摸事件？"><a href="#视图如何判断自己能否响应触摸事件？" class="headerlink" title="视图如何判断自己能否响应触摸事件？"></a>视图如何判断自己能否响应触摸事件？</h2><p>以下情况不能响应触摸事件：</p><ul><li>1.触摸点不在视图范围内。</li><li>2.不允许交互： 视图的<code>userInteractionEnabled = NO</code>。</li><li>3.隐藏：<code>hidden = YES</code>，如果视图隐藏了，则不能响应事件。</li><li>4.透明度：当视图的透明度小于等于0.01时，不能响应事件。</li></ul><h2 id="寻找最佳响应者的原理"><a href="#寻找最佳响应者的原理" class="headerlink" title="寻找最佳响应者的原理"></a>寻找最佳响应者的原理</h2><h3 id="hitTest-withEvent"><a href="#hitTest-withEvent" class="headerlink" title="hitTest:withEvent:"></a>hitTest:withEvent:</h3><p>每个<code>UIView</code>都有一个<code>hitTest:witnEvent:</code>方法。这个方法是寻找最佳响应者的核心方法，同时又是传递事件的桥梁。它的作用是询问事件在当前视图中的响应者。<code>hitTest:withEvent:</code>返回一个<code>UIView</code>对象，作为当前视图层次中的响应者。其默认实现是：</p><ul><li>若当前视图无法响应事件，则返回nil。</li><li>若当前视图能响应事件，但无子视图可响应事件，则返回当前视图。</li><li>若当前视图能响应事件，同时有子视图能响应，则返回子视图层次中的事件响应者。</li></ul><p>开始时<code>UIApplication</code>调用<code>UIWindow</code>的<code>hitTest:wuithEvent:</code>方法将触摸事件传递给<code>UIWindow</code>，如果<code>UIWindow</code>能够响应触摸事件，则调用<code>hitTest：withEvent：</code>将事件传递给其子是视图并询问子视图上的最佳响应者，这样一级一级传递下去，获取最终的最佳响应者。<br><code>hitTest:withEvent:</code>的代码实现大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    //3种状态无法响应事件</span><br><span class="line">     if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha &lt;= 0.01) return nil; </span><br><span class="line">    //触摸点若不在当前视图上则无法响应事件</span><br><span class="line">    if ([self pointInside:point withEvent:event] == NO) return nil; </span><br><span class="line">    //从后往前遍历子视图数组 </span><br><span class="line">    int count = (int)self.subviews.count; </span><br><span class="line">    for (int i = count - 1; i &gt;= 0; i--) </span><br><span class="line">    &#123; </span><br><span class="line">        // 获取子视图</span><br><span class="line">        UIView *childView = self.subviews[i]; </span><br><span class="line">        // 坐标系的转换,把触摸点在当前视图上坐标转换为在子视图上的坐标</span><br><span class="line">        CGPoint childP = [self convertPoint:point toView:childView]; </span><br><span class="line">        //询问子视图层级中的最佳响应视图</span><br><span class="line">        UIView *fitView = [childView hitTest:childP withEvent:event]; </span><br><span class="line">        if (fitView) </span><br><span class="line">        &#123;</span><br><span class="line">            //如果子视图中有更合适的就返回</span><br><span class="line">            return fitView; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    //没有在子视图中找到更合适的响应视图，那么自身就是最合适的</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意这里的方法<code>pointInside:withEvent:</code>，这个方法是判断触摸点是否在视图范围内。默认的实现是如果触摸点在视图范围内则返回<code>YES</code>，否则返回<code>NO</code>。<br>下面我们在上图中的每个视图层次中添加三个方法来验证之前的分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [super hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [super pointInside:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击视图，打印出来的结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-[AView hitTest:withEvent:]</span><br><span class="line">-[AView pointInside:withEvent:]</span><br><span class="line">-[CView hitTest:withEvent:]</span><br><span class="line">-[CView pointInside:withEvent:]</span><br><span class="line">-[EView hitTest:withEvent:]</span><br><span class="line">-[EView pointInside:withEvent:]</span><br><span class="line">-[EView touchesBegan:withEvent:]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这和我们的分析是一致的。</p><h2 id="触摸事件的响应"><a href="#触摸事件的响应" class="headerlink" title="触摸事件的响应"></a>触摸事件的响应</h2><p>通过<code>hitTest:withEvent:</code>已经找到了最佳响应者，现在要做的事情是让这个最佳响应者触摸事件。这个最佳响应者对于触摸事件拥有决定权，它可以决定是自己响应这个事件，也可以自己响应之后还把它传递给其他响应者，这个响应者构成的就是响应链。<br>响应者对于事件的响应和传递都是在<code>touchesBegan:withEvent</code>这个方法中完成的。该方法默认的实现是将该方法沿着响应链往下传递<br>响应者对于接受到的事件有三种操作：</p><ul><li>1.默认的操作。不拦截，事件会沿着默认的响应链自动往下传递。</li><li>2.拦截，不在往下分发事件，重写<code>touchesBegan:withEvent:</code>方法，不调用父类的<code>touchesBegan:withEvent:</code>方法。</li><li>3.不拦截，继续往下分发事件，重新<code>touchesBegan:withEvent</code>方法，并调用父类<code>touchesBegan:withEvent:</code>方法。<br>我们一般在编写代码时，如果某个视图响应事件，会在该视图类中重写<code>touchesBegan:withEvent:</code>方法，但是并不会调用父类的<code>touchesBegan:withEvent:</code>方法，这样我们就把这个事件拦截下来，不在沿着响应链往下传递。那么我们为什么想要沿着响应链传递事件就要写父类的<code>touchesBegan:withEvent:</code>方法呢？因为父类的<code>touchesBegan:withEvent:</code>方法默认是向下传递的。重写<code>touchesBegan:withEvent:</code>并调用父类的方法就是既对触摸事件实现了响应，又将事件沿着响应链传递了。</li></ul><h3 id="响应链中的事件传递规则"><a href="#响应链中的事件传递规则" class="headerlink" title="响应链中的事件传递规则"></a>响应链中的事件传递规则</h3><p>每一个响应者对象都又一个<code>nextResponder</code>方法，用来获取响应链中当前响应者对象的下一个响应者。硬刺，如果事件的最佳响应者确定了，那么整个响应链也就确定了。<br>对于响应者对象，默认的<code>nextResponse</code>对象如下：</p><ul><li>UIView<br>若视图是UIViewController的view，则其<code>nextResponder</code>是UIViewController，若其只是单独的视图，则其<code>nextResponser</code>是其父视图。</li><li>UIViewController<br>若该视图是window的根视图，则其<code>nextResponser</code>是UIViewController，若其是由其他视图控制器present的，则其nextResponder是presenting view controller。</li><li>UIWindow<br>nextResponder为UIApplication对象。<br>如果最佳响应者对象是UITextField，则响应链为：UITextField-&gt;UIView-&gt;UIView-&gt;UIViewController-&gt;UIWindow-&gt;UIApplication-&gt;UIApplicationDelegate.在父类的<code>touchesBegan:withEvent:</code>方法中，可能调用了<code>[self.nextResponder touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event]</code>这样来将事件沿着响应链传递。</li></ul><h3 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h3><p><code>UIControl</code>是系统提供的能够以<code>target-action</code>模式处理触摸事件的控件，iOS中<code>UIButton</code>、<code>UISegmentedControl</code>、<code>UISwitch</code>等控件都是UIControl的子类。当<code>UIControl</code>跟踪到触摸事件时，会向其上添加的<code>target</code>发送事件以执行<code>action</code>。<code>UIConotro</code>l是<code>UIView</code>的子类，因此本身也具备<code>UIResponder</code>应有的身份。</p><h6 id="UIControl会阻止父视图上的手势识别器的行为，也就是UIControl的执行优先级比父视图上面的UIGestureRecognizer要高，但是比UIControl自身的UIGestureRecognizer优先级要低。"><a href="#UIControl会阻止父视图上的手势识别器的行为，也就是UIControl的执行优先级比父视图上面的UIGestureRecognizer要高，但是比UIControl自身的UIGestureRecognizer优先级要低。" class="headerlink" title="UIControl会阻止父视图上的手势识别器的行为，也就是UIControl的执行优先级比父视图上面的UIGestureRecognizer要高，但是比UIControl自身的UIGestureRecognizer优先级要低。"></a>UIControl会阻止父视图上的手势识别器的行为，也就是UIControl的执行优先级比父视图上面的UIGestureRecognizer要高，但是比UIControl自身的UIGestureRecognizer优先级要低。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;系统响应阶段&quot;&gt;&lt;a href=&quot;#系统响应阶段&quot; class=&quot;headerlink&quot; title=&quot;系统响应阶段&quot;&gt;&lt;/a&gt;系统响应阶段&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.手指触摸屏幕，屏幕感受到触摸后，将事件交给&lt;code&gt;IOKit&lt;/code&gt;来处理。&lt;/l</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>IOS UITextFiled 用中文键盘输英文出现空格的解决方案</title>
    <link href="http://example.com/2018/07/22/IOS-UITextFiled-%E7%94%A8%E4%B8%AD%E6%96%87%E9%94%AE%E7%9B%98%E8%BE%93%E8%8B%B1%E6%96%87%E5%87%BA%E7%8E%B0%E7%A9%BA%E6%A0%BC%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2018/07/22/IOS-UITextFiled-%E7%94%A8%E4%B8%AD%E6%96%87%E9%94%AE%E7%9B%98%E8%BE%93%E8%8B%B1%E6%96%87%E5%87%BA%E7%8E%B0%E7%A9%BA%E6%A0%BC%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2018-07-22T09:14:32.000Z</published>
    <updated>2022-10-20T08:29:39.135Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>获取textFiled的值的时候，英文，数字键盘是没有问题的，假设输入的是abcd，获取的值是abcd，但是如果使用中文键盘的时候，同样输入abcd，获取到的却是a b c d 字符之间出现了空格。</p></blockquote><p>试了这方法 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *strUrl = [urlString stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];</span><br></pre></td></tr></table></figure><p>并没什么用<br>然后再利用这个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *strUrl = [urlString  stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];</span><br></pre></td></tr></table></figure><p>也没什么用</p><p>最终找到此方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *strUrl = [[urlString componentsSeparatedByCharactersInSet:[NSCharacterSet whitespaceCharacterSet]] componentsJoinedByString:@&quot;&quot;];</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;获取textFiled的值的时候，英文，数字键盘是没有问题的，假设输入的是abcd，获取的值是abcd，但是如果使用中文键盘的时候，同样输入abcd，获取到的却是a b c d 字符之间出现了空格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;试了这</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UIScrollView下拉刷新加载数据</title>
    <link href="http://example.com/2017/11/25/UIScrollView%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE/"/>
    <id>http://example.com/2017/11/25/UIScrollView%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE/</id>
    <published>2017-11-25T09:07:04.000Z</published>
    <updated>2022-10-26T08:02:34.710Z</updated>
    
    <content type="html"><![CDATA[<h5 id="首先为UIScrollView添加加载提示View"><a href="#首先为UIScrollView添加加载提示View" class="headerlink" title="首先为UIScrollView添加加载提示View"></a>首先为UIScrollView添加加载提示View</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UILabel *refresh = [[UILabel alloc] initWithFrame:CGRectMake(0, -50, 320, 50)];</span><br><span class="line">refresh.text  = @&quot;下拉刷新&quot;;</span><br><span class="line">self.refresh = refresh;</span><br><span class="line">refresh.tag = 0;</span><br><span class="line">[scrollV addSubview:refresh];</span><br></pre></td></tr></table></figure><h5 id="实现UIScrollViewDelegate"><a href="#实现UIScrollViewDelegate" class="headerlink" title="实现UIScrollViewDelegate"></a>实现UIScrollViewDelegate</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//offset发生改变</span><br><span class="line"></span><br><span class="line">-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123;</span><br><span class="line">    if (scrollView.contentOffset.y &lt;= -50) &#123;</span><br><span class="line">        if (self.refresh.tag == 0) &#123;</span><br><span class="line">            self.refresh.text = @&quot;松开刷新&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        self.refresh.tag = 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">       //防止用户在下拉到contentOffset.y &lt;= -50后不松手，然后又往回滑动，需要将值设为默认状态</span><br><span class="line">        self.refresh.tag = 0;</span><br><span class="line">        self.refresh.text = @&quot;下拉刷新&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//即将结束拖拽</span><br><span class="line">- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint*)targetContentOffset&#123;</span><br><span class="line">    if (self.refresh.tag == 1) &#123;</span><br><span class="line">        [UIView animateWithDuration:.3 animations:^&#123;</span><br><span class="line">            self.refresh.text = @&quot;加载中&quot;;</span><br><span class="line">            scrollView.contentInset = UIEdgeInsetsMake(50.0f, 0.0f, 0.0f, 0.0f);</span><br><span class="line">        &#125;];</span><br><span class="line">        //数据加载成功后执行；这里为了模拟加载效果，一秒后执行恢复原状代码</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [UIView animateWithDuration:.3 animations:^&#123;</span><br><span class="line">                self.refresh.tag = 0;</span><br><span class="line">                self.refresh.text = @&quot;下拉刷新&quot;;</span><br><span class="line">                scrollView.contentInset = UIEdgeInsetsMake(0, 0, 0, 0);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;首先为UIScrollView添加加载提示View&quot;&gt;&lt;a href=&quot;#首先为UIScrollView添加加载提示View&quot; class=&quot;headerlink&quot; title=&quot;首先为UIScrollView添加加载提示View&quot;&gt;&lt;/a&gt;首先为UIScroll</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>程序执行流程语句</title>
    <link href="http://example.com/2017/11/25/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%AF%AD%E5%8F%A5/"/>
    <id>http://example.com/2017/11/25/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%AF%AD%E5%8F%A5/</id>
    <published>2017-11-25T09:07:04.000Z</published>
    <updated>2022-10-26T03:09:36.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="if-else语法"><a href="#if-else语法" class="headerlink" title="if-else语法"></a>if-else语法</h3><ul><li>if-else语法，只有一个一个语块被执行</li><li>if和else都是java中的关键字</li><li>把if-else看作一个表达式，程序整体还是顺序执行的</li><li>使用if-else来多买两个包子<br>下面就从买包子问题来理解： 买三个包子， 如果是刚出笼的热包子呢，就多买两个呢？<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class BuyBaoZi &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int baozi = 3;</span><br><span class="line">        boolean iSHotBaozi = false;</span><br><span class="line">        System.out.println(&quot;买了&quot;+baozi+&quot;个肉包子&quot;);</span><br><span class="line">        if (iSHotBaozi)&#123;</span><br><span class="line">            baozi = baozi + 2;</span><br><span class="line">            System.out.println(&quot;包子刚出笼，买了&quot;+baozi+&quot;个肉包子&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;买了&quot;+baozi+&quot;个肉包子&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="if-else的嵌套"><a href="#if-else的嵌套" class="headerlink" title="if-else的嵌套"></a>if-else的嵌套</h3><p>求最大的数</p><ul><li>if-else就是一个语句，可以是另一个语句的一部分，也可以是if-else的一部分，即嵌套。<br>下从求a，b，c三个数的最大数来理解：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class JudgeSize &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 99;</span><br><span class="line">        int b = 88;</span><br><span class="line">        int c = 99;</span><br><span class="line">        if (a == b &amp;&amp; b == c) &#123;</span><br><span class="line">            System.out.println(&quot;a,b,c的值相同&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (a &gt; b) &#123;</span><br><span class="line">                if (a &gt; c) &#123;</span><br><span class="line">                    System.out.println(&quot;a是最大的值，为&quot; + a);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (a == c) &#123;</span><br><span class="line">                        System.out.println(&quot;a和c的最大值，为&quot; + a);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        System.out.println(&quot;c是最大值，为&quot; + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (b &gt; c) &#123;</span><br><span class="line">                    if (a == b) &#123;</span><br><span class="line">                        System.out.println(&quot;a和b等大，为&quot; + a);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        System.out.println(&quot;b最大，为&quot; + b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (c == b) &#123;</span><br><span class="line">                        System.out.println(&quot;b和c等大，为&quot; + c);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        System.out.println(&quot;c最大，为&quot; + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="循环for语句"><a href="#循环for语句" class="headerlink" title="循环for语句"></a>循环for语句</h3><ul><li>使用for语句让程序简洁</li><li>让程序在满足某条件时，重复执行某个代码块，for是Java中的关键字</li><li>初始语句在for循环开始前执行一次，以后不再执行；循环体条件表达式在每次循环体执行前会执行，如果为true ，则执行循环体，否则循环结束；循环体后语句会在每次循环执行后被执行；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (初始语句;循环体条件表达式;循环体后语句) &#123;</span><br><span class="line">     for循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>下面来看下for语句的简单例程：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Print26Chars &#123;</span><br><span class="line">    public static  void main(String[] args)&#123;</span><br><span class="line">        char ch = &#x27;A&#x27;;</span><br><span class="line">        int num = ch;</span><br><span class="line">        for (int i = 0;i&lt;26;i++)&#123;</span><br><span class="line">            System.out.println((num+i) + &quot;\t&quot;+(char)(num+i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Break语句"><a href="#Break语句" class="headerlink" title="Break语句"></a>Break语句</h3><ul><li>break语句可以结束循环<br>下面来看下在求整除程序中使用break提前结束循环：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class FindDiv &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int div = 100;</span><br><span class="line">        int divsor = 2000000000;</span><br><span class="line">        int found = 0;</span><br><span class="line">        int n = 10;</span><br><span class="line">        String start = &quot;从&quot; + div + &quot;开始&quot;;</span><br><span class="line">        while (found &lt; n)&#123;</span><br><span class="line">            if (div &lt; 0)&#123;</span><br><span class="line">                System.out.println(&quot;被除数溢出，计算结束&quot;);</span><br><span class="line">            break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (div%divsor == 0)&#123;</span><br><span class="line">                found++;</span><br><span class="line">                System.out.println(div + &quot;可以整除&quot; + divsor + &quot;，商是&quot; + (div / divsor));</span><br><span class="line">            &#125;</span><br><span class="line">            div++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(start+&quot;,共找到&quot;+found+&quot;个可以整除&quot;+divsor+&quot;的数。&quot;);</span><br><span class="line">        System.out.println(div);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><ul><li>跳过不符合条件的循环</li><li>continue语句可以结束当次循环的执行，开始下一次循环体的执行</li></ul><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><ul><li>条件表达式结果是一个boolean值，如果为true，则执行循环体，如果为false，则循环结束。</li><li>while循环体是一个代码块，所以while循环也是可以嵌套别的语句，包括while语句，for语句，if-else语句。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while（条件表达式）&#123;</span><br><span class="line">       while循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>do-while语句循环体至少执行一次。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">      while循环体;</span><br><span class="line">&#125;</span><br><span class="line">while（条件表达式）;</span><br></pre></td></tr></table></figure></li></ul><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><ul><li>switch语句的语法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch(用于比较的int值)&#123;</span><br><span class="line">    case 目标值1，对应一个 if else(xxx):</span><br><span class="line">           匹配后可以执行的语句 </span><br><span class="line">    case 目标值2，不可以于别的case子句重复:</span><br><span class="line">           匹配后可以执行的语句</span><br><span class="line">    default(对应最后的else，可选):</span><br><span class="line">           匹配后可以执行的语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>switch语句中用于比较的值，必须是int类型</li><li>switch语句是适用于有固定多个目标匹配值，然后执行不同的逻辑情况</li><li>必须使用break语句显示的结束一个case子句，否则switch第一个match的case语句开始执行直到遇到break语句或者switch语句结束</li><li>default子句是可选的，如果所有的case语句都没有匹配上，才会执行default中的代码。</li><li>switch语句例程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class SwitchNum &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int n = 99;</span><br><span class="line"></span><br><span class="line">        String str = n + &quot;对应的中文数字是：&quot;;</span><br><span class="line">        switch (n)&#123;</span><br><span class="line">            case 1:</span><br><span class="line">                str+=&quot;壹·&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                str+=&quot;贰&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                str+=&quot;叁&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                str+=&quot;肆&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 5:</span><br><span class="line">                str+=&quot;伍&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 6:</span><br><span class="line">                str+=&quot;陆&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 7:</span><br><span class="line">                str+=&quot;柒&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 8:</span><br><span class="line">                str+=&quot;扒&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case 9:</span><br><span class="line">                str+=&quot;玖&quot;;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;错误的值&quot;+n+&quot;。值需要在大于等于1，小于等于9之间。&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;if-else语法&quot;&gt;&lt;a href=&quot;#if-else语法&quot; class=&quot;headerlink&quot; title=&quot;if-else语法&quot;&gt;&lt;/a&gt;if-else语法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;if-else语法，只有一个一个语块被执行&lt;/li&gt;
&lt;li&gt;if和el</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>类（class）语法元素</title>
    <link href="http://example.com/2017/11/25/%E7%B1%BB%EF%BC%88class%EF%BC%89%E8%AF%AD%E6%B3%95%E5%85%83%E7%B4%A0/"/>
    <id>http://example.com/2017/11/25/%E7%B1%BB%EF%BC%88class%EF%BC%89%E8%AF%AD%E6%B3%95%E5%85%83%E7%B4%A0/</id>
    <published>2017-11-25T09:07:04.000Z</published>
    <updated>2022-10-26T03:09:27.453Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    System.out.println(&quot;hello world!你好，世界&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类——class</li><li><code>HelloWorld</code> 是类名，要与文件名一致。</li><li><code>public class</code> ——告诉Java类名要与代码文件一致，是类的修饰符。</li><li><code>public static void</code>是方法修饰符号。</li><li><code>String[] args</code>是方法参数。</li><li>大括号内是方法的内容，又称方法体（method body）。</li><li><code>main</code> 方法最为特殊的一点是，他是Java程序的入口。</li><li>System.out.println是Java提供的内置功能，可以将内容输出。</li><li>小括号里的内容是参数（parameter）。</li><li>没有参数的情况下，System.out.println()会输出一行空行。</li></ul><h2 id="总结关键知识点"><a href="#总结关键知识点" class="headerlink" title="总结关键知识点"></a>总结关键知识点</h2><ul><li>class 后面的名字是类名</li><li>类名必须与源文件的文件名相同，文件名后缀必须是小写的java</li><li>mian方法是Java程序执行的入口</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>iOS触摸事件响应原理</title>
    <link href="http://example.com/2016/10/17/iOS%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2016/10/17/iOS%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E5%8E%9F%E7%90%86/</id>
    <published>2016-10-17T09:03:21.000Z</published>
    <updated>2022-10-20T08:30:45.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统响应阶段"><a href="#系统响应阶段" class="headerlink" title="系统响应阶段"></a>系统响应阶段</h1><ul><li>1.手指触摸屏幕，屏幕感受到触摸后，将事件交给<code>IOKit</code>来处理。</li><li>2.<code>iOKit</code>将触摸事件封装成<code>iOHIDEvent</code>对象，并通过<code>mach port</code>传递给<code>SpringBoard</code>进程。</li></ul><blockquote><p><code>mach port</code>是进程端口，各进程间通过它来通信。<code>Springboard</code>是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统收到的触摸事件。</p></blockquote><ul><li>3.<code>Springboard</code>由于接收到触摸事件，因此触发了系统进程的主线程的<code>runloop</code>的<code>source</code>回掉。发生触摸事件的时候，你有可能正在桌面上翻页，也有可能正在头条上看新闻，如果是前者，则触发<code>Springboard</code>主线程的<code>runloop</code>的<code>source0</code>回调，将桌面系统交给系统进程去消耗。而如果是后者，则将触摸事件通过<code>IPC</code>传递给前台<code>app</code>进程，后面的事便是<code>APP</code>内部对于触摸事件的响应了。</li></ul><h1 id="APP响应触摸事件"><a href="#APP响应触摸事件" class="headerlink" title="APP响应触摸事件"></a>APP响应触摸事件</h1><ul><li><p>1.<code>APP</code>进程的<code>mach port</code>接收来自<code>Springboard</code>的触摸事件，主线程<code>runloop</code>被唤醒，触发<code>source1</code>回调。</p></li><li><p>2.<code>source1</code>回调又触发了一个<code>source0</code>回调，将接收到的<code>IOHIDEvent</code>对象封装成<code>UIEven</code>t对象，此时<code>APP</code>将正式开始对于触摸的响应。</p></li><li><p>3.<code>source0</code>回调将触摸事件添加到<code>UIApplication</code>的事件队列，当触摸事件出队后<code>UIApplication</code>为触摸事件寻找最佳响应者。</p></li><li><p>4.寻找到最佳响应着之后，接下来的事情便是事件在响应链中传递和响应。</p></li></ul><h1 id="触摸-事件-响应者"><a href="#触摸-事件-响应者" class="headerlink" title="触摸 事件 响应者"></a>触摸 事件 响应者</h1><h2 id="触摸"><a href="#触摸" class="headerlink" title="触摸"></a>触摸</h2><p>触摸对象即<code>UITouch</code>对象。一个手指触摸屏幕，就会生成一个<code>UITouch</code>对象，如果多个手指同时触摸，就会生成多个<code>UITouch</code>对象。多个手指先后触摸，如果系统判断多个手指触摸的是同一个地方，那么不会生成多个<code>UITouch</code>对象，而是更新这个<code>UITouch</code>对象，改变其<code>tap count</code>。如果对歌手指触摸的不是同一个地方，那么就会产生对个<code>UITouch</code>对象。</p><h2 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h2><p>触摸事件即<code>UIEvent</code>。<code>UIEvent</code>即对<code>UITouch</code>的一次封装。由于一次触摸事件并不止有一个触摸对象，可能是多指同时触摸。触摸对象集合可以通过<code>allUITouchs</code>属性来获取。</p><h2 id="响应者"><a href="#响应者" class="headerlink" title="响应者"></a>响应者</h2><p>响应者即<code>UIResponser</code>，<code>UIView</code>，<code>UIViewController</code>，<code>UIApplication</code>，<code>UIAppdelegate</code>等实例都是<code>UIResponser</code>，响应者响应触摸事件是由下面的方法来实现的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//手指触碰屏幕，触摸开始</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">//手指在屏幕上移动</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">//手指离开屏幕，触摸结束</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">//触摸结束前，某个系统事件中断了触摸，例如电话呼入</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="寻找最佳响应者"><a href="#寻找最佳响应者" class="headerlink" title="寻找最佳响应者"></a>寻找最佳响应者</h2><p>当<code>APP</code>通过<code>mach port</code>得到这个触摸事件时，<code>APP</code>中有那么多<code>UIView</code>或者<code>UIViewController</code>，到底应该谁去响应呢？寻找最佳响应者就是找出这个优先级最高的响应对象。</p><ul><li>寻找最佳响应着的具体流程如下：</li><li>1.<code>UIApplication</code>首先将事件传递给窗口对象（<code>UIWindow</code>），如果有多个<code>UIWindow</code>对象，则先选择最后加上的<code>UIWindow</code>对象。</li><li>2.若<code>UIWindow</code>对象能响应这个触摸事件，则继续向其子视图传递，向子视图传递时也是先传递给最后加上的子视图。</li><li><ol start="3"><li>若子视图无法响应该事件，则返回父视图，再传递给倒数第二个加入该父视图的子视图。</li></ol></li></ul><h2 id="视图如何判断自己能否响应触摸事件？"><a href="#视图如何判断自己能否响应触摸事件？" class="headerlink" title="视图如何判断自己能否响应触摸事件？"></a>视图如何判断自己能否响应触摸事件？</h2><p>以下情况不能响应触摸事件：</p><ul><li>1.触摸点不在视图范围内。</li><li>2.不允许交互： 视图的<code>userInteractionEnabled = NO</code>。</li><li>3.隐藏：<code>hidden = YES</code>，如果视图隐藏了，则不能响应事件。</li><li>4.透明度：当视图的透明度小于等于0.01时，不能响应事件。</li></ul><h2 id="寻找最佳响应者的原理"><a href="#寻找最佳响应者的原理" class="headerlink" title="寻找最佳响应者的原理"></a>寻找最佳响应者的原理</h2><h3 id="hitTest-withEvent"><a href="#hitTest-withEvent" class="headerlink" title="hitTest:withEvent:"></a>hitTest:withEvent:</h3><p>每个<code>UIView</code>都有一个<code>hitTest:witnEvent:</code>方法。这个方法是寻找最佳响应者的核心方法，同时又是传递事件的桥梁。它的作用是询问事件在当前视图中的响应者。<code>hitTest:withEvent:</code>返回一个<code>UIView</code>对象，作为当前视图层次中的响应者。其默认实现是：</p><ul><li>若当前视图无法响应事件，则返回nil。</li><li>若当前视图能响应事件，但无子视图可响应事件，则返回当前视图。</li><li>若当前视图能响应事件，同时有子视图能响应，则返回子视图层次中的事件响应者。</li></ul><p>开始时<code>UIApplication</code>调用<code>UIWindow</code>的<code>hitTest:wuithEvent:</code>方法将触摸事件传递给<code>UIWindow</code>，如果<code>UIWindow</code>能够响应触摸事件，则调用<code>hitTest：withEvent：</code>将事件传递给其子是视图并询问子视图上的最佳响应者，这样一级一级传递下去，获取最终的最佳响应者。<br><code>hitTest:withEvent:</code>的代码实现大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    //3种状态无法响应事件</span><br><span class="line">     if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha &lt;= 0.01) return nil; </span><br><span class="line">    //触摸点若不在当前视图上则无法响应事件</span><br><span class="line">    if ([self pointInside:point withEvent:event] == NO) return nil; </span><br><span class="line">    //从后往前遍历子视图数组 </span><br><span class="line">    int count = (int)self.subviews.count; </span><br><span class="line">    for (int i = count - 1; i &gt;= 0; i--) </span><br><span class="line">    &#123; </span><br><span class="line">        // 获取子视图</span><br><span class="line">        UIView *childView = self.subviews[i]; </span><br><span class="line">        // 坐标系的转换,把触摸点在当前视图上坐标转换为在子视图上的坐标</span><br><span class="line">        CGPoint childP = [self convertPoint:point toView:childView]; </span><br><span class="line">        //询问子视图层级中的最佳响应视图</span><br><span class="line">        UIView *fitView = [childView hitTest:childP withEvent:event]; </span><br><span class="line">        if (fitView) </span><br><span class="line">        &#123;</span><br><span class="line">            //如果子视图中有更合适的就返回</span><br><span class="line">            return fitView; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    //没有在子视图中找到更合适的响应视图，那么自身就是最合适的</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意这里的方法<code>pointInside:withEvent:</code>，这个方法是判断触摸点是否在视图范围内。默认的实现是如果触摸点在视图范围内则返回<code>YES</code>，否则返回<code>NO</code>。<br>下面我们在上图中的每个视图层次中添加三个方法来验证之前的分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [super hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    return [super pointInside:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击视图，打印出来的结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-[AView hitTest:withEvent:]</span><br><span class="line">-[AView pointInside:withEvent:]</span><br><span class="line">-[CView hitTest:withEvent:]</span><br><span class="line">-[CView pointInside:withEvent:]</span><br><span class="line">-[EView hitTest:withEvent:]</span><br><span class="line">-[EView pointInside:withEvent:]</span><br><span class="line">-[EView touchesBegan:withEvent:]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这和我们的分析是一致的。</p><h2 id="触摸事件的响应"><a href="#触摸事件的响应" class="headerlink" title="触摸事件的响应"></a>触摸事件的响应</h2><p>通过<code>hitTest:withEvent:</code>已经找到了最佳响应者，现在要做的事情是让这个最佳响应者触摸事件。这个最佳响应者对于触摸事件拥有决定权，它可以决定是自己响应这个事件，也可以自己响应之后还把它传递给其他响应者，这个响应者构成的就是响应链。<br>响应者对于事件的响应和传递都是在<code>touchesBegan:withEvent</code>这个方法中完成的。该方法默认的实现是将该方法沿着响应链往下传递<br>响应者对于接受到的事件有三种操作：</p><ul><li>1.默认的操作。不拦截，事件会沿着默认的响应链自动往下传递。</li><li>2.拦截，不在往下分发事件，重写<code>touchesBegan:withEvent:</code>方法，不调用父类的<code>touchesBegan:withEvent:</code>方法。</li><li>3.不拦截，继续往下分发事件，重新<code>touchesBegan:withEvent</code>方法，并调用父类<code>touchesBegan:withEvent:</code>方法。<br>我们一般在编写代码时，如果某个视图响应事件，会在该视图类中重写<code>touchesBegan:withEvent:</code>方法，但是并不会调用父类的<code>touchesBegan:withEvent:</code>方法，这样我们就把这个事件拦截下来，不在沿着响应链往下传递。那么我们为什么想要沿着响应链传递事件就要写父类的<code>touchesBegan:withEvent:</code>方法呢？因为父类的<code>touchesBegan:withEvent:</code>方法默认是向下传递的。重写<code>touchesBegan:withEvent:</code>并调用父类的方法就是既对触摸事件实现了响应，又将事件沿着响应链传递了。</li></ul><h3 id="响应链中的事件传递规则"><a href="#响应链中的事件传递规则" class="headerlink" title="响应链中的事件传递规则"></a>响应链中的事件传递规则</h3><p>每一个响应者对象都又一个<code>nextResponder</code>方法，用来获取响应链中当前响应者对象的下一个响应者。硬刺，如果事件的最佳响应者确定了，那么整个响应链也就确定了。<br>对于响应者对象，默认的<code>nextResponse</code>对象如下：</p><ul><li>UIView<br>若视图是UIViewController的view，则其<code>nextResponder</code>是UIViewController，若其只是单独的视图，则其<code>nextResponser</code>是其父视图。</li><li>UIViewController<br>若该视图是window的根视图，则其<code>nextResponser</code>是UIViewController，若其是由其他视图控制器present的，则其nextResponder是presenting view controller。</li><li>UIWindow<br>nextResponder为UIApplication对象。<br>如果最佳响应者对象是UITextField，则响应链为：UITextField-&gt;UIView-&gt;UIView-&gt;UIViewController-&gt;UIWindow-&gt;UIApplication-&gt;UIApplicationDelegate.在父类的<code>touchesBegan:withEvent:</code>方法中，可能调用了<code>[self.nextResponder touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event]</code>这样来将事件沿着响应链传递。</li></ul><h3 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h3><p><code>UIControl</code>是系统提供的能够以<code>target-action</code>模式处理触摸事件的控件，iOS中<code>UIButton</code>、<code>UISegmentedControl</code>、<code>UISwitch</code>等控件都是UIControl的子类。当<code>UIControl</code>跟踪到触摸事件时，会向其上添加的<code>target</code>发送事件以执行<code>action</code>。<code>UIConotro</code>l是<code>UIView</code>的子类，因此本身也具备<code>UIResponder</code>应有的身份。</p><h6 id="UIControl会阻止父视图上的手势识别器的行为，也就是UIControl的执行优先级比父视图上面的UIGestureRecognizer要高，但是比UIControl自身的UIGestureRecognizer优先级要低。"><a href="#UIControl会阻止父视图上的手势识别器的行为，也就是UIControl的执行优先级比父视图上面的UIGestureRecognizer要高，但是比UIControl自身的UIGestureRecognizer优先级要低。" class="headerlink" title="UIControl会阻止父视图上的手势识别器的行为，也就是UIControl的执行优先级比父视图上面的UIGestureRecognizer要高，但是比UIControl自身的UIGestureRecognizer优先级要低。"></a>UIControl会阻止父视图上的手势识别器的行为，也就是UIControl的执行优先级比父视图上面的UIGestureRecognizer要高，但是比UIControl自身的UIGestureRecognizer优先级要低。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;系统响应阶段&quot;&gt;&lt;a href=&quot;#系统响应阶段&quot; class=&quot;headerlink&quot; title=&quot;系统响应阶段&quot;&gt;&lt;/a&gt;系统响应阶段&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.手指触摸屏幕，屏幕感受到触摸后，将事件交给&lt;code&gt;IOKit&lt;/code&gt;来处理。&lt;/l</summary>
      
    
    
    
    <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="iOS" scheme="http://example.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客for Mac的搭建步骤</title>
    <link href="http://example.com/2016/05/29/Hexo%E5%8D%9A%E5%AE%A2-for-Mac%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/"/>
    <id>http://example.com/2016/05/29/Hexo%E5%8D%9A%E5%AE%A2-for-Mac%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/</id>
    <published>2016-05-29T07:04:41.000Z</published>
    <updated>2022-10-26T07:59:55.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、环境配置及安装"><a href="#一、环境配置及安装" class="headerlink" title="一、环境配置及安装"></a>一、环境配置及安装</h1><h2 id="1-Node-js"><a href="#1-Node-js" class="headerlink" title="1.Node.js"></a>1.Node.js</h2><p> 移步<a href="https://nodejs.org/en/">Node.js</a>官网进行安装。</p><h2 id="2-Git"><a href="#2-Git" class="headerlink" title="2.Git"></a>2.Git</h2><p>Xcode自带Git环境，或者移步<a href="https://git-scm.com/">Git官网</a>进行安装，再或者使用Homebrew安装：</p><pre><code>$ brew install git</code></pre><p>当安装完Node.js和Git之后，就可以进行Hexo安装了：</p><pre><code>$ sudo npm install -g hexo-cli</code></pre><p>安装成功之后可以cd到你想要存放博客的目录，默认为~&#x2F;目录，执行建站命令：</p><pre><code>$ hexo init BlogName$ npm install// 成功之后的目录结构如下├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><p>命令执行结束后，就可以正式使用Hexo了，使用debug模式进行查看：</p><pre><code>$ hexo s --debug</code></pre><p>访问<code>http://localhost:4000</code>就可以看到Hexo的默认界面了。</p><h1 id="二、托管博客"><a href="#二、托管博客" class="headerlink" title="二、托管博客"></a>二、托管博客</h1><p>在本地Hexo搭建好之后就要选择服务器进行托管，这里只讲一下通过Github进行托管的方法。</p><h2 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1.创建仓库"></a>1.创建仓库</h2><p>进入Github新建仓库，名称格式为UserName.github.io，例如ningspeals.github.io。然后将本地Hexo的站点配置文件的配置仓库修改为当前仓库的git地址 ：</p><pre><code>$ cd ~/blog/$ open _config.yml// 修改repositorydeploy:  type: git  repository: https://github.com/ningspeals/ningspeals.github.com.gitbranch: master</code></pre><p>此处注意:后面要接Space，这种格式才能被Hexo识别</p><h2 id="2-配置ssh-key"><a href="#2-配置ssh-key" class="headerlink" title="2.配置ssh key"></a>2.配置ssh key</h2><p>仓库配置好之后，要为你的Github添加ssh public key。</p><p>SSH 密钥对可以让您方便的登录到 SSH 服务器，而无需输入密码。由于您无需发送您的密码到网络中，SSH 密钥对被认为是更加安全的方式。</p><p>SSH 密钥对总是成双出现的，一把公钥，一把私钥。公钥可以自由的放在您所需要连接的 SSH 服务器上，而私钥必须稳妥的保管好。</p><p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录 shell，不再要求密码。这样子，我们即可保证了整个登录过程的安全，也不会受到中间人攻击。</p><p>—— archlinux page</p><p>理解完ssh key之后就可以进行生成了：</p><pre><code>$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;Enter file in which to save the key (/Users/xuhaoran/.ssh/id_rsa): // 输入绝对地址和名称，直接enter使用默认Enter passphrase (empty for no passphrase):  // 输入ssh key的密码，直接enter是不使用密码// 生成成功The key&#39;s randomart image is:+---[RSA 2048]----+|    ..o .    ..+ ||     oo. .    o.o||     +  o .  o +B||      o+ +. + =.%||       +S.++ + B+||      ..+O= E   *||         +.o   .o||        .      . ||                 |+----[SHA256]-----+</code></pre><p>成功生成之后使用任意方法打开.public文件，复制里面的密钥，粘贴到Github -&gt; Settings -&gt; SSH and GPG keys -&gt; New SSH key -&gt;Key中，Title可以随意写。</p><h1 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h1><p>Hexo会自动生成.md文件在~&#x2F;BlogName&#x2F;source&#x2F;_posts目录下，可以使用各种Markdown编辑器进行博客的书写了。</p><p>在每篇文章里面可以配置Front-matter，来标记类别、时间、标签等：</p><pre><code>title: Terminal命令小结date: 2017-11-22 13:56:34tags:     - Terminal Command Line</code></pre><p>书写完成之后生成generate静态文件后进行部署deploy操作，会让你的文章发到Github托管的服务器上：</p><pre><code>$ hexo g -d</code></pre><p>日常书写之外，如果你还想定制多样化的博客样式，可以使用各种Theme，Hexo默认的样式为landscape，我的博客的样式为yilia。其他各种样式可以去Hexo官网主题搜索。</p><p>例如找到yilia主题后进入其Github，使用git进行安装：</p><pre><code>$ git clone https://github.com/iissnan/hexo-theme-yilia themes/yilia</code></pre><p>之后修改站点配置文件中的theme属性：</p><pre><code>theme: yilia</code></pre><p>最后清空缓存并重新生成部署：</p><p>$ hexo clean<br>$ hexo g -d</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、环境配置及安装&quot;&gt;&lt;a href=&quot;#一、环境配置及安装&quot; class=&quot;headerlink&quot; title=&quot;一、环境配置及安装&quot;&gt;&lt;/a&gt;一、环境配置及安装&lt;/h1&gt;&lt;h2 id=&quot;1-Node-js&quot;&gt;&lt;a href=&quot;#1-Node-js&quot; class</summary>
      
    
    
    
    <category term="使用工具" scheme="http://example.com/categories/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="其他" scheme="http://example.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建个人博客</title>
    <link href="http://example.com/2015/11/05/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2015/11/05/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2015-11-05T04:47:44.000Z</published>
    <updated>2022-10-26T07:59:28.804Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="使用工具" scheme="http://example.com/categories/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="其他" scheme="http://example.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
